## 分布式一致性
- 分布式一致性算法（Consensus Algorithm）是一个分布式计算领域的基础性问题，其最基本的功能是为了在==多个进程之间对某个（某些）值达成一致（强一致），进而解决分布式系统的可用性问题（高可用）==。
- Paxos是==基于消息传递且具有高度容错特性的一致性算法==，是目前最重要的分布式一致性算法，很多人都把它作为“分布式一致性协议”的代名词

## 背景
- 在常见的分布式系统中，总会发生诸如机器宕机或网络异常（包括消息的延迟、丢失、重复、乱序，还有网络分区）等情况。
- Paxos算法需要解决的问题就是==如何在一个可能发生上述异常的分布式系统中，快速且正确地在集群内部对某个数据的值==（并不只是狭义上的某个数，它可以是一条日志，也可以是一条命令）达成一致，并且保证不论发生以上任何异常，都不会破坏整个系统的一致性

## 一致性协议
一致性协议根据是否允许数据分歧可以分为两种：
- 单主协议（不允许数据分歧）：整个分布式系统就像一个单体系统，所有写操作都由主节点处理并且同步给其他副本。例如主备同步、2PC、Paxos 都属于这类协议。
- 多主协议（允许数据分歧）：所有写操作可以由不同节点发起，并且同步给其他副本。例如 Gossip、POW
- 核心区别在于是否允许多个节点发起写操作，单主协议只允许由主节点发起写操作，因此它可以保证操作有序性，==一致性更强==。而多主协议允许多个节点发起写操作，因此它不能保证操作的有序性，只能做到==弱一致性==

#### 单主协议
单主协议的共同点在于都会用一个主节点来负责写操作，这样能够保证全局写的顺序一致性，它有另一个名字叫定序器
##### 主备复制
- 主备复制可以说是最常用的数据复制方法，也是最基础的方法，很多其他协议都是基于它的变种。 
- 主备复制要求所有的写操作都在主节点上进行，然后将操作的日志发送给其他副本。
- 由于主备复制是有延迟的，所以==它实现的是最终一致性==。

主备复制的实现方式：
- 主节点处理完写操作之后立即返回结果给客户端，写操作的日志异步同步给其他副本
- 好处是性能高，客户端不需要等待数据同步
- 缺点是如果主节点同步数据给副本之前数据缺失了，那么这些数据就永久丢失了
- MySQL的主备同步就是典型的异步复制

##### 两阶段提交
- 两阶段提交（2PC）是关系型数据库常用的保持分布式事务一致性的协议，它也属于同步复制协议，即数据都同步完成之后才返回客户端结果。发现2PC保证所有节点数据一致之后才返回给客户端，实现了顺序一致性
- 2PC 把数据复制分为两步：
1. 表决阶段：主节点将数据发送给所有副本，每个副本都要响应提交或者回滚，如果副本投票提交，那么它会将数据放到暂存区域，等待最终提交。
2. 提交阶段：主节点收到其他副本的响应，如果副本都认为可以提交，那么就发送确认提交给所有副本让它们提交更新，数据就会从暂存区域移到永久区域。只要有一个副本返回回滚就整体回滚
- 为了保证一致性和可用性，2PC一旦出现网络分区或者节点不可用就会被拒绝写操作，把系统变成只读的
- 由于 2PC 容易出现节点宕机导致一直阻塞的情况，所以在数据复制的场景中不常用，一般多用于分布式事务中

##### 分区容忍的一致性协议
分区容忍的一致性协议也是只有一个主节点负责写入（提供顺序一致性），但它跟 2PC 的区别在于它只需要保证大多数节点（一般是超过半数）达成一致就可以返回客户端结果，这样可以提高了性能，同时也能容忍网络分区（少数节点分区不会导致整个系统无法运行）。
## 基础概念
#### 角色
- 在Paxos算法中，有三种角色：
1. Proposer
2. Acceptor
3. Learners
- 具体的实现中，一个进程可能同时充当多种角色。比如一个进程可能既是Proposer又是Acceptor又是Learner
- 还有一个很重要的概念叫提案（Proposal，最终要达成一致的value就在提案里。批准后的提案叫决议（value）

#### 行为
- Proposer可以提出（propose）提案
- Acceptor可以接受（accept）提案
- 如果某个提案被选定（chosen），那么该提案里的value就被选定了
- 『对某个数据的值达成一致』，指的是Proposer、Acceptor、Learner都认为同一个value被选定（chosen）
1. Proposer：只要Proposer发的提案被Acceptor接受（刚开始先认为只需要一个Acceptor接受即可，在推导过程中会发现需要半数以上的Acceptor同意才行），Proposer就认为该提案里的value被选定了
2. Acceptor：只要Acceptor接受了某个提案，Acceptor就认为该提案里的value被选定了
3. Learner：Acceptor告诉Learner哪个value被选定，Learner就认为那个value被选定

#### 四个约束
- P1:一个acceptor必须接受(accept)第一次收到的提案;
- P2a:一旦一个具有value v的提案被批准(chosen)，那么之后任何acceptor 再次接受(accept)的提案必须具有value v;
- P2b:一旦一个具有value v的提案被批准(chosen)，那么以后任何 proposer 提出的提案必须具有value v;
- P2c:如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受(accept)编号小于n的任何提案，要么他们已经接受(accpet)的所有编号小于n的提案中编号最大的那个提案具有value v;

## 问题描述
#### 问题要求
- 假设有一组可以提出（propose）value（value在提案Proposal里）的进程集合。
- 一致性算法需要保证提出的这么多value中，只有一个value被选定（chosen）。
- 如果没有value被提出，就不应该有value被选定。
- 如果一个value被选定，那么所有进程都应该能学习（learn）到这个被选定的value。

#### 安全性
一致性算法，安全性（safaty）要求如下
- 只有被提出的value才能被选定
- 只有一个value被选定，并且如果某个进程认为某个value被选定了，那么这个value必须是真的被选定的那个
- ==目标是保证最终有一个提出的value被选定，当一个value被选定后，进程最终也能学习到这个value==

#### 可能的情况
假设不同角色之间可以通过发送消息来进行通信，那么：
- 每个角色以任意的速度执行，可能因出错而停止，也可能会重启
- 一个value被选定后，所有的角色可能失败然后重启，除非那些失败后重启的角色能记录某些信息，否则等他们重启后无法确定被选定的值。
- 消息在传递过程中可能出现任意时长的延迟，可能会重复，也可能丢失，但是消息不会被损坏，即消息内容不会被篡改（拜占庭将军问题）


## 算法过程
Paxos算法分为两个阶段。具体如下：
#### 阶段一： prepare阶段： 
- 当Porposer希望提出方案V1，首先发出prepare请求至大多数Acceptor。Prepare请求内容为序列号<SN1>;
- 当Acceptor接收到prepare请求<SN1>时，检查自身上次回复过的prepare请求<SN2>
1. 如果SN2>SN1，则忽略此请求，直接结束本次批准过程;
2. 否则检查上次批准的accept请求<SNx，Vx>，并且回复<SNx，Vx>；如果之前没有进行过批准，则简单回复<OK>;

#### 阶段二：accept批准阶段： 
- 经过一段时间，收到一些Acceptor回复，回复可分为以下几种:
1. 回复数量满足多数派，并且所有的回复都是<OK>，则Porposer发出accept请求，请求内容为议案<SN1，V1>;
2. 回复数量满足多数派，但有的回复为：<SN2，V2>，<SN3，V3>……则Porposer找到所有回复中超过半数的那个，假设为<SNx，Vx>，则发出accept请求，请求内容为议案<SN1，Vx>;
3. 回复数量不满足多数派，Proposer尝试增加序列号为SN1+，转1继续执行;

- 经过一段时间，收到一些Acceptor回复，回复可分为以下几种:
1. 回复数量满足多数派，则确认V1被接受;
2. 回复数量不满足多数派，V1未被接受，Proposer增加序列号为SN1+，转1继续执行;

- 在不违背自己向其他proposer的承诺的前提下，acceptor收到accept 请求后即接受并回复这个请求。

## 算法优化
- ==Paxos算法在出现竞争的情况下，其收敛速度很慢==，甚至可能出现活锁的情况，例如当有三个及三个以上的proposer在发送prepare请求后，很难有一个proposer收到半数以上的回复而不断地执行第一阶段的协议。因此，==为了避免竞争，加快收敛的速度，在算法中引入了一个Leader这个角色==，在正常情况下同时应该最多只能有一个参与者扮演Leader角色，而其它的参与者则扮演Acceptor的角色，同时所有的人又都扮演Learner的角色
- 在这种优化算法中，只有Leader可以提出议案，从而避免了竞争使得算法能够快速地收敛而趋于一致，此时的paxos算法在本质上就退变为两阶段提交协议。但在异常情况下，系统可能会出现多Leader的情况，但这并不会破坏算法对一致性的保证，此时多个Leader都可以提出自己的提案，优化的算法就退化成了原始的paxos算法
- 一个Leader的工作流程主要有分为三个阶段：
1. 学习阶段 向其它的参与者学习自己不知道的数据(决议);
2. 同步阶段 让绝大多数参与者保持数据(决议)的一致性;
3. 服务阶段 为客户端服务，提议案

