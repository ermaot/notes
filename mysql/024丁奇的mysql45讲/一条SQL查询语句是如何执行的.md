
## MySQL语句的基本执行过程
这张图是极客时间丁奇在MySQL的45讲中的
![image](8FB378E8017C4C4D9C149F5D76CEAFF0)
## 丁奇：
#### 大体来说，MySQL 可以分为 Server 层和存储引擎层两部分。
- ==Server 层==包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。
- ==存储引擎层==负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL5.5.5版本开始成为了默认存储引擎
- 从图中不难看出，不同的存储引擎共用一个Server 层

#### 连接器
- 第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：
```
mysql -h$ip -P$port -u$user -p
```
- 连接命令中的 mysql 是客户端工具，用来跟服务端建立连接。在完成经典的 TCP 握手后，连接器就要开始认证你的身份，这个时候用的就是你输入的用户名和密码。
1. 如果用户名或密码不对，你就会收到一个"Access denied for user"的错误，然后客户端程序结束执行。
2. 如果用户名密码认证通过，连接器会到权限表里面查出你拥有的权限。之后，这个连接里面的权限判断逻辑，==都将依赖于此时读到的权限==（这就意味着，即使对这个用户的权限做了修改，不会影响已经存在连接的权限，只有再新建的连接才会使用新的权限设置）。
- 连接完成后，如果你没有后续的动作，这个连接就处于空闲状态
- 你可以在 show processlist 命令中看到执行的命令（包括空闲的）
```
> show processlist;
+----+------+-----------------+------+---------+------+-------+------------------+----------+
| Id | User | Host            | db   | Command | Time | State | Info             | Progress |
+----+------+-----------------+------+---------+------+-------+------------------+----------+
| 87 | root | localhost:42244 | NULL | Sleep   |   28 |       | NULL             |    0.000 |
| 89 | root | localhost:42292 | NULL | Query   |    0 | NULL  | show processlist |    0.000 |
+----+------+-----------------+------+---------+------+-------+------------------+----------+
2 rows in set (0.00 sec)

```
- 客户端如果太长时间没动静，连接器就会自动将它断开，时间是由参数 wait_timeout 控制的，默认值是 8 小时。
- 建立连接的过程通常是比较复杂的，所以建议你在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。（相关阅读：连接池）
- MySQL 在执行过程中临时使用的内存是管理在连接对象里面的，全部使用长连接后，会带来内存占用过高的问题
1. 定期断开长连接。使用一段时间，或者程序里面判断执行过一个占用内存的大查询后，断开连接，之后要查询再重连。
2. 如果你用的是 MySQL 5.7 或更新版本，可以在每次执行一个比较大的操作后，通过执行 mysql_reset_connection 来重新初始化连接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

#### 查询缓存
连接建立完成后，就可以执行 select 语句了。执行逻辑就会来到查询缓存。
- 之前执行过的语句及其结果可能会以 key-value 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。MySQL拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。
- 对表的更新会清除该表相关的查询缓存。对更新频繁的系统，查询缓存效率很低（[==看如何计算缓存命中率==](https://note.youdao.com/)）
- MySQL 8.0 版本直接将查询缓存的整块功能删掉了

## 分析器
#### 词法分析
分析器先会做“词法分析”。一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。
https://yq.aliyun.com/articles/71979
- MySQL 的词法分析器是手工打造的，并且为了提高关键字的查找效率做了针对性的优化
- MySQL 手工打造的词法分析器对应的源代码文件是 sql/sql_lex.h 和 sql/sql_lex.cc
- 词法分析的入口函数是MYSQLlex()。解析出一个token的函数为lex_one_token()。
- 词法分析出来的每个 token 都会对应一个语法分析器中的终结符，它们的字符串表示在 sql/lex.h 中。
- 这些符号被分为两组，SQL 关键字以及 SQL 函数，在代码中对应数组 symbols[] 和 sql_functions[]。
- 通常而言，在语法/词法分析过程中为了判断某个 token 是否为 SQL 的关键字，可以直接二分查找字符串数组。
- 考虑到关键字列表是固定的一个集合，MySQL 对此作了专门的优化，用 Trie 树来进一步提高效率


#### 查找树的实现
- 查找树的产生用的是一个独立的小程序 gen_lex_hash[.cc]
- CMake 产生的 Makefile 规则为在文件 sql/CMakeFiles/sql.dir/build.make 


## 使用查找树
![image](B6D9EB6A288647FA89BB97A7563F51F3)
gen_lex_hash.cc 的代码注释中有一个树的示例
```
for this structure, presented program generate next searching-structure:

+-----------+-+-+-+
|       len |1|2|3|
+-----------+-+-+-+
|first_char |0|0|a|
|last_char  |0|0|d|
|link       |0|0|+|
                 |
                 V
       +----------+-+-+-+--+
       |    1 char|a|b|c|d |
       +----------+-+-+-+--+
       |first_char|d|0|0|0 |
       |last_char |n|0|0|-1|
       |link      |+|0|0|+ |
                   |     |
                   |     V
                   |  symbols[2] ( "DAY" )
                   V
+----------+--+-+-+-+-+-+-+-+-+-+--+
|    2 char|d |e|f|j|h|i|j|k|l|m|n |
+----------+--+-+-+-+-+-+-+-+-+-+--+
|first_char|0 |0|0|0|0|0|0|0|0|0|0 |
|last_char |-1|0|0|0|0|0|0|0|0|0|-1|
|link      |+ |0|0|0|0|0|0|0|0|0|+ |
            |                    |
            V                    V
         symbols[0] ( "ADD" )  symbols[1] ( "AND" )


```


#### 产生查找树：
1. 读取关键字数组，产生一个Trie树（参看函数 generate_find_structs）；。
2. 调整这棵树，并产生一个数组（也就是一个不用链表表示的树，参看函数 print_find_structs）。
![image](F3620FD879324FAE8E793E5695430A7E)
- 处理过程
1. nsert_symbols 处理的是 SQL 关键字
2. insert_sql_functions 处理的是函数名
3. get_hash_struct_by_len 处理的是树的根节点
4. insert_into_hash 处理的是树的内节点

==递归执行==
#### 语法分析
做完了这些识别以后，就要做“语法分析”。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。

## 优化器
静态优化
动态优化
## 执行器
- 先判断是否有权限（==这一步应该属于预处理阶段==），没有则返回权限错误
- 如果命中查询缓存，则返回结果之前，还要做权限验证；查询在优化器之前调用precheck验证权限
- 执行器流程
1. 调用引擎接口取表的第一行，判断是否找到满足条件；满足则记录到结果集，如果不满足则跳过
2. 调用引擎接口取下一行，重复此过程，直到表的最后一行
3. 执行器返回上述过程的全部结果集
- 调用的取满足条件的第一行接口与满足条件下一行接口，都在引擎中定义好，与服务器层互通
- rows_examined 与引擎扫描行数可能不一致
