## 索引
#### 缓冲池、顺序读取和随机读取
- 缓冲池
1. 读操作：读取指定的大小的数据块（页），放入缓冲池；下次读取，先判断是否在缓冲池中，如果在则直接读取，如果不在则再读取磁盘
2. 写操作：先读取页进入缓冲池，对页做修改，然后将修改后的“脏页”异步写入磁盘
3. LRU算法维护缓冲池
4. mysql缓冲池是基于存储引擎的（MyISAM：key_buffer_size;   innodb: innodb_buffer_pool_size ）
![缓冲池对mysql性能影响（数据大小18G）](pic/%E7%B4%A2%E5%BC%951-%E7%BC%93%E5%86%B2%E6%B1%A0%E5%AF%B9mysql%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D.jpg)

- 顺序读取<p>
顺序地读取磁盘上的页（逻辑上顺序）
- 随机读取
访问的页是不连续的


#### 数据结构与算法
##### 二分查找法（折半查找法）
##### 二叉查找树与平衡二叉树（特殊的二叉树，节点的两子树最大高度差为1）
##### 二叉树的旋转


#### B+树
所有记录节点按照键值大小排列，各叶子节点使用指针连接
![B+树](pic/%E7%B4%A2%E5%BC%952-B%2B%E6%A0%91.png)

##### 填充因子
B+使用填充因子来控制树的==删除==

在mysql8里，可以修改

```
> show variables like "%fill%";
+--------------------+-------+
| Variable_name      | Value |
+--------------------+-------+
| innodb_fill_factor | 100   |
+--------------------+-------+
1 row in set (0.00 sec)
```

但mysql5.5和mariadb无此参数

##### B+树索引
- B+一般高度2 ~ 4层，即查找一个键值一般只需要2 ~ 4次IO操作
- MySQL的索引是存储引擎实现的，也就是说各引擎的索引实现方式不同
1. innodb 的B+索引
- innodb存储引擎是索引组织表（Index Organized Table，IOT），即数据文件是按照B+方式存放数据的
- B+树的键值为主键，若没有显式指定，则会自动创建一个6字节的列为主键
- B+数索引分为聚集索引（clustered index）和辅助索引（secondary index）
- 索引页大小为16kb，无法更改
- 聚集索引是根据主键创建的B+树，叶子节点放了表中所有记录
- 辅助索引是根据主键创建的B+树，叶子节点放了索引值及对应的主键值
- 书签查找（bookmark lookup）。通过辅助索引查找数据，可能还需要通过主键值查找聚集索引来得到数据
2. MyISAM 的B+索引
- MyISAM所有数据放MYD文件中
- B+是辅助索引，放MYI文件中
- 索引页大小为1KB，不可修改（mariadb可以通过 myisam_block_size 修改）

```
> show variables like "%myisam_block_size%";
+-------------------+-------+
| Variable_name     | Value |
+-------------------+-------+
| myisam_block_size | 1024  |
+-------------------+-------+


```

- 无聚集索引，索引的叶子节点放的键值是在MYD的文件位置


#### cardinality
- cardinality表示的唯一记录数量的预估值，显示的是索引的选择性
- cardinality / rows_of_the_table 越接近1越好

```
> show index from test;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+
| test  |          0 | PRIMARY  |            1 | Id          | A         |          10 |     NULL | NULL   |      | BTREE      |         |               |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+

```
cardinality / rows_of_the_table = 10 /10 = 1
- cardinality 通过采样的方式统计的
- 表中1 / 16的数据发生变化  或者 innodb内部计数器stat_modified_count > 2000 000 000 000
- 采样过程
1. 取得B+中页节点的数量A
2. 随机选取8个叶子节点，统计记录个数∑
3.  cardinality = ∑ * A /8<p>
∴==cardinality 非精确值 ； 每次查询值可能不一样==
- 可以使用analyze 更新cardinality（mysql的analyze针对的是表）

```
> analyze table test;
+-----------+---------+----------+----------+
| Table     | Op      | Msg_type | Msg_text |
+-----------+---------+----------+----------+
| test.test | analyze | status   | OK       |
+-----------+---------+----------+----------+

```


#### 联合索引
mysql可以对多列创建联合索引
- 每一个索引键值，有多个索引列
- 放在前面的索引列是有序的，后面的不能保证顺序

#### 覆盖索引
innodb支持覆盖索引（covering index）或者索引覆盖（index coverage）：从辅助索引中即可查到信息，而不需要查询聚集索引，减少IO

#### 优化器不适用索引的情况
- 多发生于范围查找、join等情况
- 当访问数据占表比例比较大（>20%），优化器会优先选择聚集索引
- 对于无法索引覆盖，优化器选择辅助索引的情况是数据量比较少


#### force index
==强制==使用某个索引
```
> select * from test force index(primary)  where id >3;
+----+----------------------------------+------+-------+-----------+
| Id | title                            | uid  | money | name      |
+----+----------------------------------+------+-------+-----------+
|  4 | 这是Uid=1的第一条数据哦          |    1 |    70 | 欧阳锋    |
|  5 | 灵白山少主                       |    4 |    99 | 欧阳克    |
|  7 | 九阴真经创始人                   |    3 |    12 | 小顽童    |
|  8 | 双手互博                         |    2 |    56 | 周伯通    |
|  9 | 销魂掌                           |    2 |    19 | 周伯通    |
| 10 | 蛤蟆功                           |    1 |    57 | 欧阳锋    |
| 11 | 绝杀掌                           |    3 |    99 | 小顽童    |
| 12 | 九阴真经                         |    3 |    84 | 老顽童    |
+----+----------------------------------+------+-------+-----------+

```
#### index hint
==建议==使用某个索引
```
> select * from test use index(primary)  where id >3;
```

#### multi range read（MRR）
==工作方式==：
1. 将查询得到的辅助索引值存放与缓存中，此时缓存中的辅助索引值是根据辅助索引的键值排序的
2. 将缓存中的键值按照ROWID排序
3. 根据ROWID进行数据访问
==好处==：
1. 使得数据访问变得比较顺序。查找辅助索引的时候，先对得到的查询结果按照主键进行排序，并按照主键顺序做书签查找
2. 减少缓冲池中页面被替换的次数
3. 转换范围查询为键值对，批量处理对键值的操作

可以在查询计划的extra中看到using mrr

#### index condition pushdown（ICP）
- 可以先根据where过滤，然后再根据索引查找记录
- 支持range, ref, eq_ref, ref_or_null类型的查询
- 支持innodb 和 myiasm
- 查询计划的extra中可以看到using index condition

#### 哈希索引（hash index）
- innodb中的哈希算法
- innodb使用哈希散列算法对字典进行查找
- 冲突机制采用链表方式
- 散列函数使用除法散列
- 自适应哈希（适用于等值查找，范围查找无能为力）

```
select * from test where id = 123;
> show engine innodb status\G;
```
可通过innodb_adaptive_hash_index控制自适应哈希特性，默认为==开启==
