## 核心类
#### 线程类
- 线程可以用来处理来自客户端的连接，线程和连接1：1对应，线程和THD对象也是1：1对应
- mysqld内的线程可以设置4个优先级（sql/mysql_priv.h中定义）

```
#if defined(__WIN__)
 #undef  FLUSH_TIME
 #define FLUSH_TIME  1800            
 #define INTERRUPT_PRIOR -2
 #define CONNECT_PRIOR   -1
 #define WAIT_PRIOR  0
 #define QUERY_PRIOR 2
 #else
 #define INTERRUPT_PRIOR 10
 #define CONNECT_PRIOR   9
 #define WAIT_PRIOR  8
 #define QUERY_PRIOR 6
 #endif /* __WIN92__ */
```

- THD类是MySQL的线程描述符类，在sql/sql_class.h中定义，在sql/sql_class.cc中实现
- THD 类的成员变量

名称 |类型 |说明
---|---|---
Lex |LEX* |指向当前查询的查询解析树的指针
Query| char*|如图4-1中所示,该变量从Statement类中继承，以字符串形式记录当前查询
Killed |Bool volatile|要将一个进程结束,设置其为true。 任何一个线程进行大量耗时工作时,需要经常确认这个变量,如果设置了true,则线程必须马上进入线程清理工作,并退出线程
slave_thread |Bool |如果该线程为从服务器线程,设置为true
system_thread| uint|线程不是由客户端请求引起时,设置这个值。2为delayed_insert _thread<p>其他还有从服务器线程、事件安排器、NDB等线程。线程若是由客户端请求引起,设置该值为0
real_id| Pthread_t |该线程在操作系统上的线程号
thread_id |ulong|MySQL服务器分配给该线程的ID号<p>读者通过show processlist看到的ID列就是thread_id的值
query_ID|ulong |内部表示的查询号,查询号以递增的方式进行操作
warn_list| List <MYSQL ERROR>| 某些查询语句会产生较多警告(Warning),这些警告会被保存在这个列表中<p>读者可通过show warnings查看这些警告
db_charset| CHARSET INFO* |当前数据库的字符集描述符
user_connect |USER_CONN*|用户连接的限制,MySQL可以设置某个用户能够发起的连接数量和单位时间内执行查询的次数
used_tables |Table_map|优化器常常引用这个参数<p>使用位图方式显示各表的开闭状态
last_insert_id| ulonglong |Auto increment设置后,MySQL会为每次插入赋予一个值<p>我们可以执行Select last_insert_ID()来查看最近插入的ID是多少
next insert_ID| ulonglong|Auto increment设置后,next _insert id就是下次插入时该列的值
server_status |uint|位图型变量<p>这个状态将发送到客户端<p>在第5章介绍网络通信时,会说明这个字段的作用
current_statement| State* |预处理语句的描述符,常被设置为0
st_transactions|Struct |事务描述符,用于管理表更新日志
Di |Delay_insert *|延迟插入操作的描述符<p>执行INSERT delayed操作,在数据表被锁时,使得客户端插入的数据
open_tables |TABLE *|线程所使用表的链表<p>表为常规表,即SELECT、UPDATE等高级查询语句中使用的表<p>至于HANDLER查询(handler_tables)和子查询衍生表(derived_tables)不属于常规表
handler_tables |TABLE *| 线程使用handler open操作打开的表<p>Handler 命令提供了直接访问底层表存储引擎的机会<p>这样的访问跳过了优化器的控制
temporary_tables |TABLE*|线程所使用临时表的链表<p>临时表的存在时间处于会话期内<p>临时表或者是由create temporary table,或者是由select语句的优化器生成线程所使用的衍生表<p>衍生表由查询语句的子语句derived_tables TABLE* 生成<p>"衍生" 这个词,在这里并不是十分准确的概念,但由于历史的原因,在MySQL中沿用至今
lock |MYSQL_LOCK*|MySQL隐式锁<p>MYSQL LOCK结构体包含了被锁定表的链表<p>MySQL的许多操作,例如select、insert、update等操作常需要锁定一些表
locked_tables |MYSQL_LOCK * |MySQL显示锁<p>使用了lock tables命令后,显示锁定的表将被记录在这个结构体内<p>若设置了这个变量,上面的 lock变量值为0
server_ID| uint32|所有参与复制功能的MySQL服务器都被赋予一个服 务器ID号<p>当主服务器执行更新操作时,它记录了原始数据库的ID到二进制日志中去
db_access| ulong|定义了当前连接使用的当前数据库对于该客户端有何种权限<p>该变量同样采取比特位掩码的方式不要被这个变量的名称所欺骗<p>不能依据上面这个
col_access| ulong|成员变量而主动推断出该变量是记录客户端对列访问的权限<p>实际上这个变量记录的是用户执行showtables时,过滤掉没有权限查看的表
master_access| ulong|在MySQL权限控制机制中,用户被赋予全局的、库级的、表级的权限
client_capabilities| ulong|在网络通信的初始阶段<p>客户端和服务器端协商双方通信能力时,所使用的描述变量
proc_info| const char*|用于描述线程当前进行的状态.Show processlist输出的Info列包含的就是这个变量的内容
host| char* |发起连接的客户端主机名<p>
priv_host| char*|MySQL用户识别是通过user@hostname 的方式识别的<p>即hiro@sun和hiro@mysqlsystems是不同的<p>该变量中保存的变量通过用户连接时指定的-h变量查询mysqluser表获得
user|char* |发起连接的客户端传入的认证用户名
priv_user| char*|该变量中保存的变量是通过用户链接时指定的-u变量查询mysqluser表获得
db| char*| 当前所在的数据库.未指定时,该变量为NULL
db_length| uint32 |上面变量db的长度
ip |char*| 发起连接客户端IP的字符串表示
host_or_ip| char*| 对IP进行DNS反向查询
packet |string |用于网络I/0的动态缓冲
system_variables | struct |该会话的系统变量，在会话期间是可变的
Net| NET |客户端连接描述符
protocol |Protocol* |网络通信协议描述符

- THD的成员函数
1. Init() -线程初始化
2. Enter_cond()- 进入线程条件变量
3. Set_time()- 设置执行开始的时间
4. Lock_time()- 获得表锁定时间
5. Insert id()- 插入自动增长ID号
6. Convert string()- 转化String
7. Charset()- 设置数据库字符集


#### Item类
- Item用于实现表达式,如查询条目、函数、where、 order、group、on子句等
- 首先Item是一个类.每个Item类的实例都包含:
1. SQL语句中某项的类似物,如where
2. 一个值
3. 数据类型描述符
- Item 类的成员变量和方法


名称 |类型 |说明
---|---|---
str_value |String |该变量的主要作用是将变量缓存到save_in_field 中
name| Char* |Select语句中的名称
orig_name |My_string |如果设置过别名,该变量就是Select语句中的别名
Next| Item* |Item链表
max_length| Uint32| Name变量的最大程度
name_length |Uint| Name变量的长度
maybe_null| My_bool |该Item是否有可能会是Null
Null_value| My_bool |该Item是否是Null
Fixed| My_bool |该Item是否由fixfields设置成固定值
is_autogenerated_name |My_bool |该Item的名称是否自动生成还是由用户设置
collation| DTCollation| 用于字符串排序;
with_subselect| My bool |该Item是否为一个子查询或包含子查询
cmp_context|Item_result |上下文比较
- 在源代码中,以下所有的SQL语句和元素均可看成Item对象:
1. 字符
2. 数据表的列
3. 会话级变量和全局变量
4. 存储过程变量
5. 各类参数
6. SQL函数、各类操作符以及like、=
- Item定义在sql/item.h中，item子类都以item_开头，如：item_buff.cc、item.cc、item_.cmpfunc.cc、item_cmpfunc.h、item_create.cc、item_create.h、item_func.cc、item_func.h、tem_geofunc.cc、item_geofunc.h、item_row.cc、item_row.h、item_strfunc.cc
- 举例：

```
Select avg (score) from mysq1systems where name=@var ;
MySQL将select分析成select链表,score 是Item_field类,average是SQL函数Item;
MySQL又将where分析成where链表,链表包括name列Item_field, @var 是会话级变量Item_string,"=" 是SQL函数Item_string
```
- MySQL如何使用Item类
1. sql_parse.cc:在add_field_to_list()函数中创建新Item对象
2. mysqld.cc: main()执行完之后, 服务器使用clean_up()清理所有Item对象
3. sys_var.cc:与系统变量相关的Item类
4. sql_class.cc: 请注意查看函数cleanup_after_query()
5. sql_lex.cc: add...to_list()这类函数中,使用了Item 对象
6. sql_select.cc: 使用Item类最多的地方
7. udf_example.cc:该程序中有不少注释可以参考

#### TABLE 表定义类
- 表类定义了MySQL数据库表在MySQL内存中的形式
- 表描述类是在表被打开时创建，表描述类创建后会被置于表缓存(table_cache)中,等待下一个查询的重用,以提高访问的效率
- 表描述类对象经常在查询解析、查询优化、访问控制和查询缓存代码中被引用
- 表描述类的定义在sql/table.h文件中。在MySQL  5.1中,表结构发生了变化,很多结构体成员被放到TABLE_SHARE类中。TABLE_SHARE表示表的元信息,例如字段定义、索引定义等,它是.frm文件在内核中的表示。TABLE类对象代表一个打开的TABLE_SHARE
- TABLE 类成员

名称 |类型 |说明
---|---|---
file |handler*| 指针指向表在存储引擎的位置
Field |Field**| 由表内所有列组成的数组
record[2] |Byte*| 一对临时缓冲,优化器的记录操作
fields| uint |表内列的数量
reclength| uint |记录长度(字节),这里所描述的长度是指记录在优化器中的长度<p>并不是MySQL存储引擎内的长度
rec_buff_length| uint |为操作一个记录而分配的临时缓冲
keys| uint| 表内索引的数量
key_ parts| uint|数据库中,若某列数据是一-个索引的组成部分<p>则称为索引分量(key part)
primary_key| uint |主键在索引数组里面的位置
null_fields| uint |可包含Null值的列数
blob_fields |uint| 数据类型是blob或text列的数量
In_use|THD*| 使用该表的线程
Frm_version |uchar| 表定义文件frm的版本号
Query_id| ulong|当前使用该表的查询ID
used_next、used_prev |TABLE*、TABLE**| 这两个成员用于实现used关系
open_next、open_prev |TABLE*、TABLE** |这两个成员用于实现opened关系
prev、next| TABLE* |THD中的open, tables关系
位图|  |
keys_in_use| Key_map |Key_map是一个对象,记录了一个查询中所能使用的所有索引<p>除非使用alter Table ... diable keys<p>在原来版本的MySQL中,Key_map是用比特位掩码来表示的<p>后来随着索引数量的增加,Key_map也变成对象
quick_keys |Key_map| 局部优化使用的索引位图
used_keys| Key map| 与keys_in_use相似,这里主要指当前查询的位图
keys_in_use_for_query |Key_map |根据FORCE KEY和IGNORE KEY的索引视图

#### Field类
- Field对象是Table类的重要组成成员之一，在任何一个操作中,总是会涉及到列,所以Field类在查询解析和查询优化中作用非常大
- Field类在代码文件sql/field.h中定义,并由sql/field.cc部分实现."部分实现"的理由是Field类是一个抽象类,虚函数由其各子类(FIELD  *文件)实现。
- Field类成员变量和函数

名称 |类型 |说明
---|---|---
Ptr| char*| 数据记录的内存地址
null_ptr| uchar*| 指针指向包含Null字段的记录
table_name |const char*| 字段所属表
field_name |const char* |字段名称
comment| LEX_STRING| 定义该字段时使用的注释
query_id| ulong|同TABLE类-一样,查询ID
Unireg_check |utype |字段类型定义,存储在frm文件中
Field_length |uint32 |该字段能够存储的最大长度
Flags| uint16|位图,记录字段定义时的其他选项<p>如NOT NULL、AUTO INCREATEMENT、ZERO FILL等
位图|
key_start |Key_map|若位图的第n位被设定为1,那么这个字段是第n个索引的第一部分
part_of_key |Key_map|若位图的第n位被设定为1,那么这个字段是第n个索引的一部分
part_of_sortkey| Key_map| B树索引使用

方法名称 |返回值类型 |说明
---|---|---
store(const char *from,<p>uint length, <p>CHARSET INFO *cs)  |  int | 将from指针指向的内存部位和Field类关联起来
store(double nr) | int | 将double类型的数字和Field类关联起来
store(longlong nr) |int | 将长整型longlong类型的数字和Field类关联起来
store_time(TIME *ltime,<p>timestamp_type t_type)| void  |将Ltime指向的时间数据和Field关联起来
val_real(void)| double|
val_str(String *str) |sting *|
result_type()| Item_result | 返回该字段中存储的数据类型是什么
cmp_type()| Item_result  |根据表达式提供的数据类型判断本字段能否转化
reset(void)|  void | 清除所有与Field关联的数据
binary()|  bool | 判断是否是二进制
maybe_null(void)|  bool | 字段是否包含NULL
move_field(char *ptr_arg)|  bool | 将字段数据的地址重新指向另外一个位置

- 各类之间的关系
![各类之间的关系](https://github.com/ermaot/notes/blob/master/mysql/005mysql%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/pic/MySQL%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81.png)
1. LEX、Item、 TABLE LIST是SQL语法分析以及SQL语句的抽象表示,Item用于实现表达式,如查询条目、函数、where、 order、 group、 on 子句等.TABLE_LIST则用来表达JOIN操作
2. Protocol和NET，前者实现数据库服务器和客户端的通信协议,例如构建协议包等,提供网络支持,如原始数据的读写
3. TABLE_SHARE和TABLE:前者代表表的元信息,例如字段定义,索引定义等;后者代表一个打开的表实例
4. handler是存储引擎接口。JOIN是SQL的执行引擎,MySQL中查询的执行要经历准备、优化、执行几个阶段

## 库函数
#### 内存操作函数
内存分配的效率直接影响着MySQL在时间和空间上的性能,无论是查询语句分析还是系统内部数据结构要求,MySQL 都需要为此及时地准备大量内存
1. 内存池初始化
这个函数准备了MEM_ROOT(内存池根),以备以后之需。该函数设置了内存分配的大小并分配第一块内存块:

```
void init_alloc_root (MEM_ROOT *mem_root,uint block_size,uint pre_alloc_size_attribute__( (unused) ) )
// mem_root:内存池指针: block_size: 需要分配的内存块数,1/ pre_alloc_size: 预分配内存大小
mem_root->free = mem_root->used = mem_root->pre_alloc = 0;
mem_root->min_mal1oc = 32;
……
```
2. 申请内存池内存
从内存池申请内存块，最终由mem_root变量指向这个内存池,参数Size指内存申请的大小:

```
gptr alloc_root (MEM_ROOT *mem_root, unsigned int Size)
#if defined (HAVE_purify) && defined (EXTRA DEBUG)
reg1 USED_MEM *next;
Size += ALIGN_SIZE (si zeof (USED_MEM) ) ;
```
3. 释放内存池
其中root是内存池指针,MyFlags 标志哪种内存可以被释放,MY_MARK_BLOCKS_FREE
表示并不释放内存,而是标志该内存可被其他线程使用;对于MY_KEEP_PREALLOC, 若没有
设置该标志,则释放预分配的内存块.具体如下:

```
void free_root (MEM ROOT *root, myf MyFlags)
regl USED_MEM *next, *o1d;
if (MyFlags & MY_MARK_BLOCKS_FREE)
mark_blocks_free (root) ;
……
```

#### 文件系统操作函数
#### 哈希表操作
#### 字符串操作
#### 宏定义

## 核心算法
#### 位图
- 比特位图用少量字节表示大量信息
- mysys/目录下的my_bitmap.c文件包含了各种操作位图的函数:
1. 设置和拆除操作(bitmap init、bitmap free)
2. 设置和清理整个比特位图或某个具体的比特位(bitmap_setbit、bitmap_fasttest_and_set、bitmap_clear_all、bitmap_set_all)
3. 对两个比特位图进行比较操作(bitmap_cmp、bitmap_intersect、bitmap_subtract、bitmap_union}
- 如save.cc、mysqld.c、sql_insert.c、log_event.cc、sql_show.cc等文件中,都大量使用到了位图
- 目前位图仍然存在不少限制
- 每次系统为位图分配空间时,采用的最小单位是字节,即8个比特位.所以某些情况下我们未必会用完8*n个比特位,这种情况下造成无法知道位图最后几位是否有意义
- 比特位图的比较操作bitmap_union所操作的两个比特位图必须是等长的
- 整个比特位图包含了大量有用的关键信息,多个线程对同一个比特位图变量操作时,要借助于互斥锁(Mutex)的帮助,互斥锁可能导致线程串行化

#### 表连接缓冲（join buffer）
- @@join_buffer_size 变量

```
> show variables like "join_buffer_size";
+------------------+--------+
| Variable_name    | Value  |
+------------------+--------+
| join_buffer_size | 131072 |
+------------------+--------+

> select @@join_buffer_size;
+--------------------+
| @@join_buffer_size |
+--------------------+
|             131072 |
+--------------------+
```
- join buffer缓存为每个连接分配join_buffer_size大小的内存；如果两个表都用了join buffer，则分配2个join_buffer_size大小的内存


#### 排序实现
- order by、group by都需要排序
- 两种排序方式：
1. 使用range、ref、index读写方式。ref   非唯一索引（主键也是唯一索引）；range  索引的范围查询；index  (代表索引覆盖，即不需要回表)
2. filesort排序算法。即将一组记录按照快排放入到内存缓存，然后这几个内存缓存按合并算法排序。使用@@sort_buffer_size控制，若结果集大于sort_buffer_size，则会创建一个临时表存放数据，性能会下降
- filesort工作模式有两种：
1. 直接模式：已经读取全部数据，排序后即是我们需要的结果
2. 指针模式：排序时，数据以<sort_key,rowid>ingshi存在。按照sort_key排序后，根据rowid找到记录
3. mysql一般使用直接模式，当被排序的记录中包含blob等变长字段时，直接模式不可行才会使用指针模式。==explain并不告诉我们使用的指针模式还是直接模式==
- 三种排序方法
1. 使用已排序索引。explain不会提及filesort。此种情况是表join第一个表有索引且就是order by的列
2. 在单表上使用filesort。explain显示using filesort。==order by的列均在join的第一个表上（还要查资料补充完整条件）==。mysql先对第一个表排序，然后将排序的表与其他表连接
3. 将join结果放入临时表，然后使用filesort。explain显示using temporary；using filesort。如果有blob等变长字段，filesort使用指针算法，则先将表的join结果存到临时表中，然后filesort

#### 字符集和校对规则
- 字符集一方面规定了MySQL如何存储字符信息，另一方面给出了字段的配需一句，每一个字符集支持一个或者多个校对规则（collation）
- MySQL字符集和校对规则的定义粒度可以小到字段级别。MySQL field结构体定义可以看到这个说明：

```
typedef struct st_mysql_field {
char *name ; /*列名称*/
char *org_name;/*如果使用了as,则这里是列的原名称*/
char *table; /*表名称*/
char *org_table; /*如果使用了as,则这里是列的原名称*/
char *db; /*表所在的库*/
char *catalog; /*表的Catalog属性 */
char *def; /*默认值(default值>*/
unsigned 1ong length; /*列宽度(创建时指定) */
unsigned long max_1ength; /*该类型的列最大宽度*/
unsigned int name_length;
unsigned int org_name_1ength;
unsigned int table_length;
unsigned int org_table_length;
unsigned int ab_1ength;
unsigned int catalog_length;
unsigned int def_length;
unsigned int flags; /* Div标志*/
unsigned int decimals; /*列中数据decimal类型的数量*/
unsigned int charsetnr;/*字符集*/
enum enum_field types type ;
} MYSQL_FIELD;
```
- 编译、安装mysql时，系统可以根据源代码sql/share/charsets/Index.xml 文件生成字符集信息
- show charset

```
> show charset;
+----------+-----------------------------+---------------------+--------+
| Charset  | Description                 | Default collation   | Maxlen |
+----------+-----------------------------+---------------------+--------+
| big5     | Big5 Traditional Chinese    | big5_chinese_ci     |      2 |
| dec8     | DEC West European           | dec8_swedish_ci     |      1 |
| cp850    | DOS West European           | cp850_general_ci    |      1 |
| hp8      | HP West European            | hp8_english_ci      |      1 |
| koi8r    | KOI8-R Relcom Russian       | koi8r_general_ci    |      1 |
| latin1   | cp1252 West European        | latin1_swedish_ci   |      1 |
| latin2   | ISO 8859-2 Central European | latin2_general_ci   |      1 |
| swe7     | 7bit Swedish                | swe7_swedish_ci     |      1 |
| ascii    | US ASCII                    | ascii_general_ci    |      1 |
| ujis     | EUC-JP Japanese             | ujis_japanese_ci    |      3 |
| sjis     | Shift-JIS Japanese          | sjis_japanese_ci    |      2 |
| hebrew   | ISO 8859-8 Hebrew           | hebrew_general_ci   |      1 |
| tis620   | TIS620 Thai                 | tis620_thai_ci      |      1 |
| euckr    | EUC-KR Korean               | euckr_korean_ci     |      2 |
| koi8u    | KOI8-U Ukrainian            | koi8u_general_ci    |      1 |
| gb2312   | GB2312 Simplified Chinese   | gb2312_chinese_ci   |      2 |
| greek    | ISO 8859-7 Greek            | greek_general_ci    |      1 |
| cp1250   | Windows Central European    | cp1250_general_ci   |      1 |
| gbk      | GBK Simplified Chinese      | gbk_chinese_ci      |      2 |
| latin5   | ISO 8859-9 Turkish          | latin5_turkish_ci   |      1 |
| armscii8 | ARMSCII-8 Armenian          | armscii8_general_ci |      1 |
| utf8     | UTF-8 Unicode               | utf8_general_ci     |      3 |
| ucs2     | UCS-2 Unicode               | ucs2_general_ci     |      2 |
| cp866    | DOS Russian                 | cp866_general_ci    |      1 |
| keybcs2  | DOS Kamenicky Czech-Slovak  | keybcs2_general_ci  |      1 |
| macce    | Mac Central European        | macce_general_ci    |      1 |
| macroman | Mac West European           | macroman_general_ci |      1 |
| cp852    | DOS Central European        | cp852_general_ci    |      1 |
| latin7   | ISO 8859-13 Baltic          | latin7_general_ci   |      1 |
| utf8mb4  | UTF-8 Unicode               | utf8mb4_general_ci  |      4 |
| cp1251   | Windows Cyrillic            | cp1251_general_ci   |      1 |
| utf16    | UTF-16 Unicode              | utf16_general_ci    |      4 |
| cp1256   | Windows Arabic              | cp1256_general_ci   |      1 |
| cp1257   | Windows Baltic              | cp1257_general_ci   |      1 |
| utf32    | UTF-32 Unicode              | utf32_general_ci    |      4 |
| binary   | Binary pseudo charset       | binary              |      1 |
| geostd8  | GEOSTD8 Georgian            | geostd8_general_ci  |      1 |
| cp932    | SJIS for Windows Japanese   | cp932_japanese_ci   |      2 |
| eucjpms  | UJIS for Windows Japanese   | eucjpms_japanese_ci |      3 |
+----------+-----------------------------+---------------------+--------+
```

- show collation

```
> show collation;
+--------------------------+----------+-----+---------+----------+---------+
| Collation                | Charset  | Id  | Default | Compiled | Sortlen |
+--------------------------+----------+-----+---------+----------+---------+
| big5_chinese_ci          | big5     |   1 | Yes     | Yes      |       1 |
| big5_bin                 | big5     |  84 |         | Yes      |       1 |
| dec8_swedish_ci          | dec8     |   3 | Yes     | Yes      |       1 |
| dec8_bin                 | dec8     |  69 |         | Yes      |       1 |
| cp850_general_ci         | cp850    |   4 | Yes     | Yes      |       1 |
| cp850_bin                | cp850    |  80 |         | Yes      |       1 |
| hp8_english_ci           | hp8      |   6 | Yes     | Yes      |       1 |
| hp8_bin                  | hp8      |  72 |         | Yes      |       1 |
……
……
```
- 相同字符集的不同校对规则有不同的id，也是mysys/charset.c 中的get_charset()调用的字符id
- 字符集处理函数

函数| 参数| 返回值
---|---|---
get_collation_number_internal() |校对规则名称 |校对规则ID
get_collation_number()|校对规则名称| 校对规则ID
get_charset_number()| 字符集名称| 校对规则ID
get_charset_name()| 校对规则名称 |字符集名称
get_intermal_charset()| 校对规则名称 |字符集类型
get_charset()| 校对规则名称 |字符集类型


## 本文来自《mysql核心内幕》祝定泽