参考了https://zhuanlan.zhihu.com/p/107282292

## 背景

网上经常有人纠结count操作的性能问题，并给出了并不一致的结论。普遍的看法是，不建议count(*)，因为这样会读取全部字段，导致大量IO。那么是否如此呢？本文就简单探讨以下，并顺带讲一讲其他的知识点

## 引擎的不同

虽然现在MySQL的默认引擎是innodb，myisam越来越非主流了。但一些知识点可以拿来讨论，并提供一些启发。

在myisam里，把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高。但如果带where条件，情况就完全不同，也会比较慢。

innodb则是需要把数据一行一行地从引擎里面读出来，然后累积计数，所以比较慢

## 如果需要高性能的count，可以怎么做？

#### 对于MySQL

1. 不建议使用MySQL的count(*)
2. 如果带where且能走覆盖索引，可以视情况考虑count(*)
3. 如果需要回表，最好不要count(*)

#### 替代方案：

1. 带自增id的，可以用最大id来近似获取
2. 使用其他的软件单独计数，比如redis
3. 使用数据聚合平台分析

## 表统计信息代替count(*)

```
> show table status like "%test_isam%";
+-----------+--------+---------+------------+------+----------------+-------------+------------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+
| Name      | Engine | Version | Row_format | Rows | Avg_row_length | Data_length | Max_data_length  | Index_length | Data_free | Auto_increment | Create_time         | Update_time         | Check_time | Collation       | Checksum | Create_options | Comment |
+-----------+--------+---------+------------+------+----------------+-------------+------------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+
| test_isam | MyISAM |      10 | Fixed      |  100 |              9 |         900 | 2533274790395903 |         1024 |         0 |           NULL | 2020-06-28 14:47:28 | 2020-06-28 14:47:53 | NULL       | utf8_general_ci |     NULL |                |         |
+-----------+--------+---------+------------+------+----------------+-------------+------------------+--------------+-----------+----------------+---------------------+---------------------+------------+-----------------+----------+----------------+---------+
1 row in set (0.00 sec)
```

里面的rows也近似表示了表当前的行数。但注意：

1. 该值使用的是采样统计
2. 采样方法：InnoDB 默认会选择 N 个数据页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了这个索引的基数
3. 这个采样估算得来的值，官方文档说误差可能达到 40% 到 50%

## 各种count的性能比较

count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加。最后返回累计值

- count(主键id)
  InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。

- count(1)，count(0)
  InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。

- count(字段)
  如果这个“字段”是定义为 not null 的话，一行行地从记录里面读出这个字段，判断不能为 null，按行累加；
  如果这个“字段”定义允许为 null，那么执行的时候，判断到有可能是 null，还要把值取出来再判断一下，不是 null 才累加。

- count(\*)
  并不会把全部字段取出来，而是专门做了优化，不取值。count(*) 肯定不是 null，按行累加

  ```
  mariadb5.56和mysql8都是一样的结果
  
  > explain extended select count(*) from partition_perf ;
  +------+-------------+----------------+-------+---------------+-------+---------+------+----------+----------+-------------+
  | id   | select_type | table          | type  | possible_keys | key   | key_len | ref  | rows     | filtered | Extra       |
  +------+-------------+----------------+-------+---------------+-------+---------+------+----------+----------+-------------+
  |    1 | SIMPLE      | partition_perf | index | NULL          | perfa | 4       | NULL | 16778029 |   100.00 | Using index |
  +------+-------------+----------------+-------+---------------+-------+---------+------+----------+----------+-------------+
  1 row in set, 1 warning (0.00 sec)
  
  
  > show warnings;
  +-------+------+------------------------------------------------------------+
  | Level | Code | Message                                                    |
  +-------+------+------------------------------------------------------------+
  | Note  | 1003 | select count(0) AS `count(*)` from `perf`.`partition_perf` |
  +-------+------+------------------------------------------------------------+
  ```

  可以看到，count(\*)已经等价与count(常数)了