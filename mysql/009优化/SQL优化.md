本文来自《千金良方：mysql性能优化金字塔法则》

## 几个概念
#### 索引
- B-Tree 和B+tree：B+Tree在子节点有指针相连
- B+Tree适合范围查询（<、>、between……and），可以直接扫描子节点
#### 聚集索引
- innodb是索引组织表，即主键和数据放一起
1. 创建表时如果指定主键则将其作为聚集索
2. 如果没有指定主键，则选择第一个NOTNULL的唯一索引作为聚集索引
3. 如果没有唯一索引，则内部会生成一个6字节的rowid作为主键
#### 二级索引（辅助索引）
- 二级索引叶子节点存储了索引值+rowid
- 存储值而不存储指针，保证主键变化时不用修改二级索引（但查询时可能需要回表）
#### 基数、选择性、回表
- 基数是字段distinct值
- 选择性是指基数与总行数比值乘以100%
可以通过show index查看Cardinality
```
> show index from test;
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| Table | Non_unique | Key_name | Seq_in_index | Column_name | Collation | Cardinality | Sub_part | Packed | Null | Index_type | Comment | Index_comment | Visible | Expression |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
| test  |          0 | idx_name |            1 | name        | A         |           0 |     NULL |   NULL |      | BTREE      |         |               | YES     | NULL       |
+-------+------------+----------+--------------+-------------+-----------+-------------+----------+--------+------+------------+---------+---------------+---------+------------+
1 row in set (0.02 sec)
```
- 查询的字段不能在（二级）索引中完全获得时，需要回表查询所需要的数据

## 联接算法
#### nest loop join（NLJ）
1. 最简单的join，外循环读取一行，根据关联条件到内循环中匹配
2. 外循环为驱动表，内循环为被驱动表
#### block nested loop join（BNL）
- 将外循环缓存起来，批量比较
- 内循环表是全表扫描，匹配join_buffer中的数据，遵循规则：
1. 联接类型为ALL、index、range，会使用到join buffer
2. join buffer由join_buffer_size控制
3. 每次联接都使用一个join_buffer，多表联接可以使用多个join_buffer
4. join_buffer只存储与查询操作相关的字段数据，而非整行记录
5. join_buffer分批缓存的是两表的联接结果，符合条件的发送到客户端
## mysql优化特性
#### ICP（索引条件下推）
筛选字段在索引中的where条件从服务器层下推到存储引擎层
- 适用场景：组合索引（a，b）where条件中a的字段是范围扫描（或者选择性非常低），那么后面索引字段b无法用到索引。没有ICP会把满足a的全部数据提取到服务器层，有ICP会将b字段条件下推到存储引擎层
- 限制：
1. 只能用于innodb和Myisam
2. 适用于range、ref、eq_ref和ref_or_null访问方式，并且需要回表
3. 适用于二级索引（非虚拟字段）

#### MRR：multi-range read
如果通过二级索引扫描时需要回表查数据，若主键顺序与二级索引顺序不一致会导致大量随机IO。MRR会将索引扫描到的数据根据ROWID排序再回表查询
#### batched key access