## 什么限制了MySQL的性能
- 最常见的瓶颈是CPU和IO
- 当数据可以放在内存中或者可以从磁盘中以足够快的速度读取时，CPU可能出现瓶颈
- 另一方面，IO瓶颈一般发生在工作所需数据远远超过有效内存容量的时候
- 如果应用程序是分布在网络上，或者有大量查询、低延迟的要求，瓶颈可能转移到网络上（网络吞吐其实也是一种IO）
- 系统性思维，透过表象看更深层次问题
## 如何为MySQL选择CPU
#### 哪个更好：更快的cpu还是更多的cpu
- 当遇到CPU密集型的工作时，MySQL通常可以从更快的CPU中获益
- 一般的服务器通常有多个插槽（socket），每个插槽上都可以插一个有多核心的CPU（执行单元），并且每个核心可能有多个硬件线程
- 一般谈CPU速度，是指执行单元的速度；而CPU数量，通常是指操作系统上看到的数量（超线程技术，使得看到的cpu数量是物理核心的若干倍）
- ==直接内存连接（directly attached memory）技术==
- 之前版本的操作系统，无法识别因为超线程出来的两个虚拟处理器实际是同一芯片，但现在操作系统已经可以了，所以无需关闭超线程
- 调优服务器的目标
1. 低延迟（快速响应）
需要高速cpu（MySQL每个查询只能使用一个CPU）
2. 高吞吐
高速CPU和多个CPU对高吞吐有利；但CPU有极限，MySQL在多个CPU不能完美扩展（新版本要好很多，可以放心扩展到16或者24个CPU或者更多）
- MySQL复制可以在高速CPU下工作非常好，但多CPU帮助不大。如果工作负载是CPU密集型，主库的并发任务传递到备库后会被简化成串行任务，所以备库的瓶颈通常是IO而不是CPU
- 具体查看SQL语句是做什么：如果是等待latch或者lock，通常需要更快cpu；如果是运行队列中等待，则更快cpu或者更多cpu都有帮助
- ==lock_open互斥量（mutex）【研究一下】==
- 通常可以通过堆栈跟踪来诊断，如pt-pmp工具
#### cpu架构
- 99%以上的非嵌入式MySQL实例，都运行在intel或者AMD的X86架构下
- 64bit是默认的，32bit已经很难买到
#### 扩展到多个cpu和核心
- 多CPU在OLTP场景中非常有用，因为OLTP通常是小操作，高并发，适合多个CPU执行（大多数web应用）
- OLTP一般使用innodb，许多并发瓶颈（innodb行级锁和Myisam的表锁，无法优化，只能尽快处理完）
- 两类并发问题
1. 逻辑并发：一般是资源的竞争，如表锁或者行锁的争用。优化策略：优化应用程序、使用不同的存储引擎、改变服务器配置、使用不同的锁定提示或者事务隔离级别
2. 内部并发：信号量、访问innodb缓冲池页面的资源争用。优化策略：尝试改变服务器设置、改变操作系统、使用不同的硬件。一般只能缓解无法彻底消灭
两个复杂之处：
- 频率调整：根据CPU压力动态改变CPU的时钟速度。但不能很好处理间歇性的突发短查询；可能会导致性能波动
- boost技术。当系统只使用一个核心时，处理器会运行在更高的时钟速度。因此想利用空闲CPU，可能会影响当前的CPU的任务。
## 平衡内存和磁盘资源
![缓存的层级](pic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%961.png)
- 利用各级缓存存放热点数据，以获得更快的访问速度。通常使用启发式方法：最近使用的数据可能会很快被再次使用；相邻的数据可能很快需要使用（空间和时间的局部性原理）
- cpu寄存器和高速缓存对于程序媛是透明的，并与硬件架构相关，由编译器和CPU管理
- 数据库缓存效率通常超过操作系统，因为操作系统缓存是为通用任务设计的，而数据库缓存是专用设计的
#### 随机IO和顺序IO
- 随机IO从缓存受益最多
- 顺序读取不能从缓存受益，因为
1. 顺序IO比随机IO快
2. 存储引擎执行顺序读比随机读快
- 随机读取通常只需要查找特定的行，但仍然需要读取一页的数据，大部分都是浪费的
#### 缓存，读和写
- 内存足够，完全可以避免磁盘的读取请求，可以只有逻辑读而无物理读，但持久化导致的物理写可以延缓却无法避免
- 缓存可以集中操作
1. 多次写入，一次刷新：一个数据库可以反复修改，但只需要一次持久化
2. IO合并：多个部分的修改可以一次写入
- WAL（预写日志）：预写日志在内存中变更页面，不马上刷新到磁盘
- 写入可以从缓冲受益，因为缓冲把随机IO转换成连续IO
#### 工作集是什么
- 工作集大小取决于应用程序，可能占总数据1%，也可能100%，如果不能全部放内存，则会导致磁盘和内存的数据交换
- 工作集可以定义为基于时间的百分比。缓存的数据越多，工作负载就越可能成为cpu密集型
- 应该依据最常用的页面集考虑工作集，而非最频繁读写的页面集
- 工作集包括数据和索引，使用缓存单位计数
- 不同存储引擎的缓存单位不一样，innodb页大小是16KB
#### 找到有效的内存/磁盘比例
- 找到良好的内存/磁盘比例最好的方式是通过试验和基准测试
- 评估缓存命中率最好的办法是查看CPU使用率（CPU的工作时间，CPU等待IO的时间各所占比例）

#### 选择硬盘
- 传统磁盘读取过程三步骤
1. 移动磁头到磁盘表面正确位置
2. 等待磁盘旋转，所需的数据在读取磁头下
3. 等待磁盘旋转过去，所有所需的数据被磁头读出

1，2步即访问时间，3即传输速度
- 小的随机查找，以1，2为主，大的顺序读主要是3
- 大量小的磁盘随机读取，一般需要考虑
1. 存储容量（==RAID是标准做法==；有时候只用磁盘的20%~30%，提高数据的局部性）
2. 传输速度：取决于主轴转速和数据存储在磁盘上的密度，以及主机系统接口的限制
3. ==访问时间：对随机查找而言，这是主要因素==
4. 主轴转速：常见7200RPM、10000RPM、15000RPM。
5. 物理尺寸：越小的磁盘，移动磁头越快，还能节省电力
## 固态存储
高质量闪存设备具备：
1. 相比硬盘有更好的随机读写性能。闪存设备通常读明显比写快
2. 相比硬盘有更好的随机读写性能（入门级固态硬盘可能比传统硬盘顺序读取慢）
3. 相比硬盘能更好支持并发。闪存设备可以支持更多的并发操作
4. 当前RDBMS技术都是针对于机械硬盘，同样成熟且深入的研究在固态存储上并没有真正出现
#### 闪存概述
- 硬盘驱动器使用旋转盘片和可移动磁头，固态存储构建在闪存上，比硬盘驱动器在某些方面更复杂
- 闪存最重要特征是迅速完成多次小单位读取，但写入之前必须擦除一个cell（比如512KB）
- 垃圾收集可能导致写放大：为了保持一些块是干净且可以被写入，设备需要回收脏块。当设备快被填满，垃圾收集就非常频繁，写方法的倍数会增加

#### 闪存技术
- 当前有两种主要的闪存设备类型：单层单元（SLC）和多层单元（MLC）
- SLC每个单元存储数据是一个比特。SLC相对更贵，但非常快，擦写寿命为100000个周期
- MLC每个单元存储2个比特、3个比特。成本更低，但速度和擦写周期也下降了（10000个）
#### 闪存的基准测试
- 闪存的基准测试是复杂且困难的，很多情况会导致测试错误，需要特定的设备只是和极大的耐心
- 闪存设备有三阶段模式：A-B-C性能特性。开始阶段运行非常快（阶段A），然后垃圾回收器开始工作，设备处于过渡态（阶段B），最后进入稳定状态（==阶段C，感兴趣的阶段==）
- 闪存需要预热，但预热终点和基准测试的起点比较难确定
- 评估闪存供应商的数据（注意写入的块大小导致的写入带宽不同）
#### 固态硬盘驱动器（SSD）
- SSD模拟SATA硬盘驱动器，兼容SATA硬盘接口和驱动
- 英特尔X-25E（企业级）；MKC的X-25M（笔记本等大众市场）；320系列
- SSD有很多便宜的品牌和型号，但并不像硬盘一样可靠
- SSD大多数设备没有板载电池，却有写缓存（不可关闭）来缓冲写入，可能会导致写丢失
###### 用SSD做RAID
- 建议对SATA SSD硬盘使用RAID
- 旧RAID控制器不支持SSD，如果RAID控制器型号末尾有一个自读，表明为SSD做好了准备，例如adaptex控制器用Z标识
- 即使支持闪存的RAID控制器，也不一定支持很好
#### PCIe存储设备
- PCIe设备不模拟硬盘驱动器，带宽比SATA硬盘大，设备在物理上更靠近CPU，延迟低
- 对PCIe不建议使用RAID，因为设备的平均无故障时间接近于主板
- 对MySQL，最著名的厂商是fusion-io和virident

#### 其他类型的固态存储
- 除了SSD和PCIe设备，还有violin memory、sandforce、texas memory systems
- 几十TB的SAN盒，主要用于大型数据中心存储的整合，性能非常高
- MySQL不适合这些存储，因为数十TB下，MySQL很难良好工作
#### 什么时候应该使用闪存
- 适合用在大量随机IO工作负载的场景下
- 单线程工作负载。多线程工作负载可以通过加大并行化程序解决
- 闪存可以为服务器整合提供巨大帮助，尤其是PCIe方式
#### 使用flashcache
- flashcache是一个linux内核模块，使用linux的设备映射器（device mapper），在内存和磁盘之间创建了一个中间层（facebook开源）
- flashcache 创建一个块设备，并且可以被分区，也可以像其他块设备一样创建文件系统。闪存设备用作读取和写入的智能高速缓存
- flashcache 是缓存系统，也需要预热，预热时间可能达到1个星期

[参考参数设置](https://blogread.cn/it/article/3951?f=wb_news)
#### 优化固态存储上的MySQL
- innodb默认配置是为硬盘驱动器定制
- ==percona server有很多提升闪存性能设计的参数==，oracle版本的innodb中已经或者将要实现
###### 改进方面包括
- 增加innodb的IO容量：闪存比机械硬盘支持更高的并发量，所以可以增加读写IO到10或15；也可以在2000~20000范围内调整 innodb_io_capacity 选项
- innodb日志文件设置更大：崩溃恢复需要随机IO访问，所以恢复时间会很长；闪存会让这个过程快很多，所以可以增大innodb日志文件（可以大于4G）
- 把一些文件从闪存转移到RAID（日志文件；小写入操作；二进制日志文件；ibdata）
1. 日志文件以512字节为单位顺序IO，除了崩溃恢复其余时间不读取，所以使用闪存比较浪费
2. 小写入操作会增加闪存设备的写放大因子，影响寿命
3. ibdata文件包含双写缓冲（doublewrite buffer）和插入缓冲（insert buffer），双写缓冲会进行很多重复写入，可以放RAID上
- 禁用预读（随机预读，线性预读）：有争议，暂不确定开销与收益谁大
- 配置innodb刷新算法。标准的innodb没有为闪存提供配置性，percona xtradb（还有mariadb），innodb_adaptive_checkpoiny选项为keep_average而非默认的estimate，可避免性能抖动
- 闪存设备innodb_flush_neighbor_pages 可以设为0，避免查找邻接脏页刷写

```
mariadb5.5
> show  variables like "%innodb_flush_neighbor%";
+-----------------------------+-------+
| Variable_name               | Value |
+-----------------------------+-------+
| innodb_flush_neighbor_pages | area  |
+-----------------------------+-------+

MySQL8
> show  variables like "%innodb_flush_neighbors%";
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| innodb_flush_neighbors | 0     |
+------------------------+-------+
1 row in set (0.00 sec)
```
- 禁止双写缓冲：在闪存上不能100%保证安全，但能提高性能50%
- 限制插入缓冲大小：插入缓冲设计用来减少更新行时不在内存中的非唯一索引引起的随机IO。限制闪存上的插入缓冲大小可避免消耗设备上的大量空间
- innodb在MySQL5.6以上，可以配置page_size

```
> show  variables like "%innodb_page_size%";
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| innodb_page_size | 16384 |
+------------------+-------+
1 row in set (0.00 sec)


```

- innodb页面校验（checksum）算法：暂时没有确定的结论。xtradb和MySQL5.6都可以修改checksum算法

```
mariadb5.5
> show  variables like "%checksum%";
+---------------------------------+-------+
| Variable_name                   | Value |
+---------------------------------+-------+
| aria_page_checksum              | ON    |
| binlog_checksum                 | NONE  |
| innodb_buffer_pool_shm_checksum | ON    |
| innodb_checksums                | ON    |
| innodb_fast_checksum            | OFF   |
| master_verify_checksum          | OFF   |
| slave_sql_verify_checksum       | ON    |
+---------------------------------+-------+


MySQL8
show  variables like "%checksum%";
+---------------------------+-------+
| Variable_name             | Value |
+---------------------------+-------+
| binlog_checksum           | CRC32 |
| innodb_checksum_algorithm | crc32 |
| innodb_log_checksums      | ON    |
| master_verify_checksum    | OFF   |
| slave_sql_verify_checksum | ON    |
+---------------------------+-------+
5 rows in set (0.00 sec)


```

## 为备库选择硬件
- 备库应该强大到足以承担主库所有的写入（需要考虑备库只能串行执行写入）
- 如果备库只是备用，则主库和备库最好有相同的硬件和配置
- 如果备库是为了扩展容量，则可以使用不同的存储引擎，更便宜的硬件或者用RAID0代替RAID5或RAID10
- 如果备库跟不上主库，可使用固态硬盘
## RAID性能优化
![RAID比较](pic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%962.png)
==这里写一篇==
#### RAID故障转移、恢复和镜像
- raid配置（除了RAID0）都提供了冗余
- RAID不能消除甚至减少备份的需求，恢复时间要看控制器、RAID等级、阵列大小、硬盘速度、以及重建时是都需要保持服务器在线
- RAID在完全相同的时间损坏也是有可能的，更常见的是两个密切相关的磁盘出现故障（很少访问的数据，在物理上损坏了，可能几个月都检测不到）
- RAID的监控很重要
#### 平衡硬件RAID和软件RAID
- 有时文件系统、操作系统或者RAID控制器会把请求序列化，可以尝试不同的RAID配置。
- 镜像冗余且性能要好，可以采用：
1. 配置一个包含5个镜像对（RAID1）的RAID10卷，对操作系统是1个卷
2. 在RAID控制器中配置5个RAID1镜像对，让操作系统使用5个卷而不是1个
3. 在RAID控制器中配置5个RAID1镜像对，然后用软件RAID0把5个卷做成一个逻辑卷，软硬结合实现RAID10
- 多种配置可能导致串行化
1. ext3文件系统每一个inode有一个单一的mutex，所以innodb的 innodb_flush_method=o_direct 时，文件系统会有inode级别的锁定，导致文件不能IO并发

[innodb_flush_method=o_direct参数参考](https://blog.csdn.net/smooth00/article/details/72725941)
2. ReiserFS文件系统，innodb打开了innodb_file_per_table选项，在RAID1基础上用RAID0做RAID10，获得5倍多的吞吐（其实是bug）
3. 串行化可能发生在任何软件或者硬件堆栈层，修复则需要更改文件系统、升级内核、暴露更多的设备给操作系统，或者使用不同软硬件RAID
- 上线新服务器，一定要做基准测试
#### RAID配置和缓存
- RAID配置可以从机器启动时进入自带的设置工具，或者从命令行运行
- 两个选项特别关注：条带的块大小（chunk size），控制器的板载缓存（RAID缓存）
- RAID条带块大小
1. 对随机IO来说更大的块更好，因为更多的读取可以从一个单一驱动器满足（理论观点。RAID控制器在大条带下工作得不好）
2. 读的单位太大，RAID缓存可能不太有效，最终读到很多额外数据
3. ==可以配置系统以便从应用到底层存储所有的块都对齐：innodb块、文件系统块、LVM、分区偏移、RAID条带、磁盘扇区。当一切都对齐时，随机读和随机写的性能可分别提高15%和23%==
- RAID缓存
使用RAID缓存的几个原因：
1. 缓存读取：这种用法很糟糕。一般操作系统和数据库服务器的缓存更大，更容易被命中，而不命中却被RAID缓存命中的概率极小，几乎一定会被刷新掉而直接读取硬盘
2. 缓存预读数据：如果数据库服务器做了自己的智能预读（innodb的预读），RAID的预读可能就没帮助，甚至可能干扰虫咬的缓冲和同步写入
3. 缓冲写入：可有双重好处，一方面可以比硬盘快得多地返回写成功信号，另一方面可以积累写操作而实现批量操作
4. 内部操作：比如计算校验位、发生故障时重建数据
- 一般情况下，RAID控制器的内存是稀缺资源，用来缓存读通常是一种浪费，但缓冲写可以加速IO
- RAID缓存缓冲写时，许多控制器可以配置延迟写入时间（1秒，5秒等）。有点是可以更批量，但缺点是更“突发”
- 写缓冲对事务日志和二进制日志(sync_binlog=1)调用fsync()非常有用，但RAID控制区需要电池备份单元（BBU）和其他非易失性存储
- 许多硬盘驱动器有自己的缓存，可能有假fsync()动作，要确保fsync真的刷新了，否则禁用磁盘缓存。
- 安装新硬件，做一次真实有效的宕机测试
[参考文章](https://www.xuebuyuan.com/zh-hant/1976645.html)
## SAN和NAS
- SAN（storage area network）和NAS（network-attached storage）是两个外部文件存储设备加载到服务器的方法，不同的是访问存储的方式
- 访问SAN设备时通过块接口，服务器直接看到一块硬盘并直接使用；通常使用光纤通道协议（FCP）或者iscsi连接服务器
- NAS设备通过基于文件协议来访问，比如NFS和SMB，通过标准的网络连接
- 还有一些设备可以同时以两种方式访问：netapp filter存储系统
- SAN允许服务器访问非常大量的硬盘（50块以上），并且通常配置大容量只能高速缓存来缓冲写入
- 许多SAN允许多节点组成集群
- SAN可以混合闪存和机械硬盘，可以有大到TB的闪存作为缓存
#### SAN基准测试
![SAN基准测试](pic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8C%E7%A1%AC%E4%BB%B6%E4%BC%98%E5%8C%963.png)

同步16kb，innodb配置O_DIRECT写入
- 因为可以缓冲合并IO，SAN可以承受大量的连续写入
- 顺序读性能不错
- 随机写不能较好合并，性能较差
- 随机读因为缓存无法命中，所以不适合
- 小的随机操作，SAN都无法获得良好的响应时间和吞吐，延时大部分是由于服务器与SAN之间的链路导致
- 基准测试至少有3个重要指标：每秒吞吐字节数、并发性、响应时间。相对于直连存储（DAS），SAN顺序读写更好，但随机读写的吞吐和延迟会很差
#### 使用基于NFS和SMB的SAN
- NFS：二进制日志存储在NFS上会损害服务器性能，关闭sync_binlog也一样
- SMB协议访问SAN或NAS，会产生更多的网络通信，会对延迟产生影响
#### MySQL在SAN上的性能
- MySQL在SAN上运行还可以：仔细做好逻辑和物理设计，包括索引和适当的服务器硬件，尽量多的内存，但引入一个新的查询，schema的变化或者频繁的操作，容易打破现状
- 哪些不适合放SAN：大量随机IO的单线程任务。比如备库的复制；批处理作业；拷贝、二进制日志、innodb的事务日志都需要小的随机IO
#### 应该使用SAN吗
一句话：不应该
## 使用多磁盘卷
- 有时候使用多个卷可以帮助解决IO负载高的问题，各种不同的IO可以互不影响
- 二进制日志和数据文件分离的真正优势，是减少崩溃后同时丢失数据和日志文件的可能
- 分离出临时目录文件（MySQL在filesort和磁盘临时表会写临时目录）。临时目录可以使用==临时内存文件系统== [tmpfs](https://blog.csdn.net/wz947324/article/details/80007122)；否则放操作系统盘
## 网络配置
- 对于大多数应用来说，最大的问题是延迟（传输很多很小的网络包）
- 运行不正常的网络：
1. 丢包（1%的丢包也会造成显著性能下降）
2. DNS损坏或者变慢。收到请求时MySQL会正向和反向DNS查找，可启用skip_name_resolve选项
- ==TC积压==可以通过back_log选项来配置，控制MySQL的传入TCP队列的大小（默认50不够，繁忙系统需要加大到数百数千）。linux系统，需要增加somaxconn设置（默认128）；检查sysctl的 tcp_max_syn_backlog 设置
- 如何设计高性能的网络：
1. 首先分析节点之间有多少跳跃点，以及物理网络布局之间的映射关系
2. 监控服务器、路由器、交换机的每个端口（开源设备监控工具：==多路由流量绘图器MRTG==；网络性能监控工具：smokeping和cacti）
3. 考虑网络物理隔离
4. 避免实时的跨数据中心的操作
5. 使用千兆网卡或者更高，或者使用网络链路聚合（连接多个网卡（NIC）[参考链接](https://blog.51cto.com/sf1314/2074459)）
6. 如果连接不多，但有很大的结果集和很多查询，可以增加TCP缓冲区

```
1. tcp 收发缓冲区默认值 
[root@ www.linuxidc.com]# cat /proc/sys/net/ipv4/tcp_rmem   
4096    87380   4161536 
87380  ：tcp接收缓冲区的默认值 
[root@ www.linuxidc.com]# cat /proc/sys/net/ipv4/tcp_wmem  
4096    16384   4161536 
16384  ： tcp 发送缓冲区的默认值 
2. tcp 或udp收发缓冲区最大值 
[root@ www.linuxidc.com]# cat /proc/sys/net/core/rmem_max  
131071 
131071：tcp 或 udp 接收缓冲区最大可设置值的一半。 
也就是说调用 setsockopt(s, SOL_SOCKET, SO_RCVBUF, &rcv_size, &optlen);  时rcv_size 如果超过 131071，那么 
getsockopt(s, SOL_SOCKET, SO_RCVBUF, &rcv_size, &optlen); 去到的值就等于 131071 * 2 = 262142 
[root@ www.linuxidc.com]# cat /proc/sys/net/core/wmem_max   
131071 
131071：tcp 或 udp 发送缓冲区最大可设置值得一半。 
跟上面同一个道理 
3. udp收发缓冲区默认值 
[root@ www.linuxidc.com]# cat /proc/sys/net/core/rmem_default    
111616：udp接收缓冲区的默认值 
[root@ www.linuxidc.com]# cat /proc/sys/net/core/wmem_default  
111616 
111616：udp发送缓冲区的默认值 
4. tcp 或udp收发缓冲区最小值 
tcp 或udp接收缓冲区的最小值为 256 bytes，由内核的宏决定； 
tcp 或udp发送缓冲区的最小值为 2048 bytes，由内核的宏决定
```
7. 调整设置以有效处理大量连接和小查询

```
# cat /proc/sys/net/ipv4/ip_local_port_range
32768	60999

# echo 1024 65535  > /proc/sys/net/ipv4/ip_local_port_range

# cat /proc/sys/net/ipv4/tcp_fin_timeout 
60
默认60秒，可以修改得短一些
```

## 选择操作系统
- linux是高性能MySQL最常用的操作系统
- solaris常用于高可靠的应用上，solaris 10 增加了ZFS文件系统，包含很多先进的故障排除工具（DTrace，良好的多线程性能）以及solaris zones虚拟化技术
- FreeBSD 对MySQL的多线程支持改善很多，ZFS也可以在FreeBSD上使用
## 选择文件系统
- 文件系统依赖于操作系统，windows下就只NTFS能用
- linux下各种文件系统性能非常接近，没有哪个系统是银弹
- ext2和ext3文件系统如果目录下文件过多会导致运行缓慢（新ext3和ext4用dir_index解决了）
- 最好使用日志文件系统（ext3、ext4、xfs、zfs、jfs），减少崩溃后文件系统的检查时间
- 非日志文件系统性能比支持事务的好（==可以使用tunefs关闭ext3的日志记录功能==）
- ext3和ext4，有三个选项控制数据怎么记日志，可以作为挂载选项
1. data=writeback：只有元数据写入日志，元数据和日志不同步。这是最快的配置，innodb有自己的事务日志，所以对innodb是安全的除非是崩溃时刚好.frm文件损坏
2. data=ordered：只有元数据写日志，但写元日志之前会先写数据，保持一致。比writeback略慢，但更安全
3. data=journal：提供原子日志的行为，在数据写入到最终位置之前记录到日志中
- 一些选项可以禁用（在/etc/fstab中添加noatime、nodiratime挂载选项可以禁用，可提高5%到10%性能）

```
/dev/sda2 /usr/lib/mysql ext3 noatime, nodiratime, data=writeback 0 1
```
- 可以调整文件系统的预读行为（innodb有自己的预读），innodb的O_DIRECT选项会自动禁用预读
- ext3的inode只有一个互斥变量，fsync有时会刷新所有脏块而不是单个文件。建议用xfs或者日益普及的ext4
## 选择磁盘队列调度策略
- linux默认是cfq（completely fair queueing完全公平排队）策略，MySQL的工作负载类型下，cfq会导致很差的响应时间
- noop调度适合没有自己调度算法的设备（如硬件RAID和SAN）
- deadline对RAID控制器和磁盘都工作良好

```
# cat /sys/block/vda/queue/scheduler 
[mq-deadline] kyber none
```

## 线程
- MySQL5.5中，Oracle提供了线程池插件
- linux提供两个线程库：LinuxThreads和新的原生POSIX线程库（NPTL）【[相关比较参考](https://www.ibm.com/developerworks/cn/linux/l-threading.html)】
- FreeBSD会加载许多线程库，线程支持从之前的很弱逐渐变好，甚至好于SMP系统上的linux。FreeBSD6以上版本，线程库是libthr
- solaris和windows对线程支持很好
- MySQL5.5之前，Myisam在windows下线程支持不佳，5.5以后提升显著
## 内存交换区
- 操作系统会因为没有足够的内存而将一些虚拟内存写到磁盘会发生内存交换，这个过程对用户进程是透明的
- swap对MySQL性能影响很大。发生内存交换时，MySQL会认为swap上的数据依然在内存，一些操作会完成前一直会被挂起。这意味着内存交换比直接做硬盘IO还要糟糕
- linux上可以用vmstat监控内存交换，查看si和so列报告的内存交换IO活动，最好为0，并且每秒低于10个块
- 修改交换区设置：
1. /proc/sys/vm/swappiness 默认值是60，对于服务器修改为0

```
# cat /proc/sys/vm/swappiness 
0
```
2. 修改引擎IO方式：innodb使用 innodb_flush_method=O_DIRECT
3. 使用MySQL的 memlock配置项，将MySQL锁定在内存
- 一些技巧是针对于特定内核版本的，所以升级要小心
## 操作系统状态
- iostat ，vmstat，mpstat
#### 如何阅读vmstat的输出

```
# vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 242052 167636 4146216    0    0     0     3    1    1  0  0 100  0  0
 0  0      0 242060 167636 4146216    0    0     0     0 1194 1444  1  0 99  0  0
 0  0      0 242060 167636 4146216    0    0     0     0 1157 1396  1  1 99  0  0
 0  0      0 242060 167636 4146232    0    0     0     0 1162 1448  1  1 99  0  0
```
- procs：r这一列显示了多少进程正在等待CPU,b列显示多少进程正在不可中断地休眠(通常意味着它们在等待ⅣO,例如磁盘、网络、用户输入,等等)
- memory：swpd列显示多少块被换出到了磁盘(页面交换).剩下的三个列显示了多少块是空闲的(未被使用)、多少块正在被用作缓冲,以及多少正在被用作操作系统的缓存
- Swap：这些列显示页面交换活动:每秒有多少块正在被换入(从磁盘)和换出(到磁盘).大部分时间我们喜欢看到si和so列是0,并且我们很明确不希望看到每秒超过10个块
- IO：这些列显示有多少块从块设备读取(bi)和写出(bo).这通常反映了硬盘IO
- system：这些列显示了每秒中断(in)和上下文切换(cs)的数量
- cpu：这些列显示所有的CPU时间花费在各类操作的百分比,包括执行用户代码(非内核)、执行系统代码(内核)、空闲,以及等待IO.如果正在使用虚拟化,则第五个列可能是st,显示了从虚拟机中"偷走"的百分比.这关系到那些虚拟机想运行但是系统管理程序转而运行其他的对象的时间.如果虚拟机不希望运行任何对象,但是系统管理程序运行了其他对象,这不算被偷走的CPU时间

#### 如何阅读iostat的输出

```
# iostat -x 4
Linux 3.10.0-862.11.6.el7.x86_64 (izm5edbv563hlvcbf71ophz) 	08/01/2019 	_x86_64_	(2 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.27    0.00    0.19    0.01    0.00   99.53

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
vda               0.00     0.30    0.01    0.69     0.25     6.58    19.50     0.00    3.27   31.80    3.00   0.42   0.03

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
           0.63    0.00    0.50    0.13    0.00   98.75

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await r_await w_await  svctm  %util
vda               0.00     2.00    0.00    0.75     0.00    11.00    29.33     0.00    0.67    0.00    0.67   0.33   0.03

```

- rrqm/s和wrqm/s：每秒合并的读和写请求."合并的"意味着操作系统从队列中拿出多个逻辑请求合并为一个请求到实际磁盘
- r/s和w/s：每秒发送到设备的读和写请求
- rsec/s和wsec/s：每秒读和写的扇区数.有些系统也输出为rkB/s和wkB/s
- avgrq-sz：请求的扇区数
- avgqu-sz：在设备队列中等待的请求数
- await：磁盘排队上花费的毫秒数.很不幸,iostat没有独立统计读和写的请求
- svctm：服务请求花费的毫秒数,不包括排队时间.
- %util：至少有一个活跃请求所占时间的百分比.这个指标无法真实反映设备的利用率
- 并发数计算：

```
concurrency = (r/s + w/s) * (svctm/1000)
或者
concurrency = avgqu-sz * svctm / await
```

#### 其他有用的工具
- mpstat 观察cpu统计
- blktrace 分析硬盘IO
#### cpu密集型机器
- cpu密集的机器一般us列占用高；如果sy列占用高超过20%，需要重视
- 合理的上下文切换（cs列），如果超过100000次或者更多，需重视
- 
#### 发生内存交换的机器
si和so列有很高的值

#### 空闲的机器
idle列值比较大