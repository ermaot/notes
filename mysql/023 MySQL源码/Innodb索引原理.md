## B+ 树与B树区别
1. B树同一个键值不出现多次，键值可能出现在叶子节点也可能出现在内节点；B+树键值一定出现在叶子节点，同时可能在非叶子节点重复出现
2. B树每一个节点都存储了真实数据，会导致每一个节点存储的数据量变小，层数比较高；B+树内节点只存储键值，层高较低
3. B树查找效率与键在B树中的位置相关；B+树复杂度对某个简称的树是固定的
4. B树中，键位置不固定，且树结构中只出现一次，节省空间但插入删除等操作复杂度增加，性能不平衡；B+树整体性能比较稳定
5. B树中，所有数据只存一份；B+树中，除了存储数据的叶子节点外，还有只存储键值数据的内节点，占用空间比B树多。
## 索引的设计
B+树的存储方式
- 将磁盘空间划分成许多大小相同的块（block）或者页（page），符合磁盘顺序读取
- 一个块内，通过链表或者数组方式管理数据；所有数据也可以有序，便于利用二分法查找对应数据
- B+树节点就是一个块。
- B+树中，内节点存储了行数据中的键，叶子节点存储所有的行数据。通过键值和指针，可以找到所需数据
## 聚簇索引和二级索引
- 每一个表只有一个聚簇索引，主键可以指定，也可以是隐藏的rowid列
- 其余索引成为二级索引（secondary index），可以有多个
- 如果索引冗余，MySQL会提示警告（但主键上重复建索引似乎不会）
```
> create index test0906_b on test0906(b);

> create index test0906_b2 on test0906(b);

> show warnings;
+---------+------+------------------------------------------------------------------------------------------------------------------------------------+
| Level   | Code | Message                                                                                                                            |
+---------+------+------------------------------------------------------------------------------------------------------------------------------------+
| Warning | 1831 | Duplicate index 'test0906_b2' defined on the table 'test.test0906'. This is deprecated and will be disallowed in a future release. |
+---------+------+------------------------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)

```
- 二级索引占用空间比聚簇索引小很多，所以统计一个表总的精确行数（count*），优化器会选最小的索引来作为统计的目标索引，因此比count(主键)快
- 回表，是指在使用二级索引时，二级索引只存储了部分数据，如果根据键值查不到目标数据，就需要通过二级索引的指针，重新搜索一遍聚簇索引。这叫回表（非覆盖索引）
- 覆盖索引是指二级索引可以直接覆盖到所需要查的数据
## 二级索引指针
聚簇索引和二级索引之间的逻辑关系
- 自定义主键的聚簇索引
1. 索引结构：【主键列】【TRXID】【ROLLPTR】【其他建表创建的非主键列】
2. 参与比较的列：主键列
3. 内节点key列：【主键列】+pageno指针
- 未定义主键的聚簇索引
1. 索引结构：【ROWID】【TRXID】【ROLLPTR】【其他建表创建的非主键列】
2. 参与比较的列：ROWID列
3. 内节点key列：【ROWID】+pageno指针
- 自定义主键的二级唯一索引
1. 索引结构：【唯一索引列】【主键列】
2. 参与比较的列：【唯一索引列】【主键列】
3. 内节点key列：【唯一索引列】+pageno指针
- 自定义主键的非二级唯一索引
1. 索引结构：【非唯一索引列】【主键列】
2. 参与比较的列：【非唯一索引列】【主键列】
3. 内节点key列：【非唯一索引列】【主键列】+pageno指针
- 未定义主键的二级唯一索引
1. 索引结构：【唯一索引列】【ROWID】
2. 参与比较的列：【唯一索引列】【ROWID】
3. 内节点key列：【唯一索引列】+pageno指针
- 未定义主键的二级非唯一索引
1. 索引结构：【非唯一索引列】【ROWID】
2. 参与比较的列：【非唯一索引列】【ROWID】
3. 内节点key列：【非唯一索引列】【ROWID】+pageno指针

## B+树网络
![B+树结构](49A51F14BCF7460C85B4EF04F5C9EFB8)
- 一条记录分两个部分，对内节点一条记录只有key但存储的时候包括了pageno，对于叶子节点没有pageno
- 每一层最左边节点页面的最左边位置，都有一个min虚拟记录，判断当前搜索是否已经到达页面边界
- 每一个页面都有==页面头和页面尾==，用来管理及标记页面状态
- 叶子节点是双链表，遍历只需要找到叶子节点最左边的节点，就可以从左至右取出所有数据且天然排序
- B+树一般是3~4层，也就是最多4次就可以完成一次数据定位，效率比较高

## Innodb索引插入过程
#### 页分裂并插入的过程（这部分说得非常简略，没有写全部的细节和过程）
1. 首先，创建一个新的叶子节点。叶子节点和内叶节点使用不同的段。
2. 如果内叶节点变成叶子节点，需要将内叶子节点页面的全部记录复制到新页面中，内叶子节点页面的最小虚记录要指向新叶子节点，同时将原记录全部删除
3. 如果树的层高变化，则会将新的层作为内叶节点。根节点的数据全部转移到新的层中，根节点的pageno指针指向新的层

#### 一个页面至少存储几条记录
==一个页面至少2条记录，否则会造成大量的节点浪费==

#### 页面结构管理
页面结构如图
![页面结构](B61C0A6A93B84FBB99B6AC086D4BFE6D)
###### 文件管理头信息
- 文件头管理信息38字节

file header（文件头）  8部分，38字节
名称|说明
---|---
fil_page_space_or_checksum|（4字节） mysql4.1之后表示checksum值
fil_page_offset|（4字节）表空间中页的偏移值，从0开始
fil_page_prev|（4字节）,顾名思义，表示前一个页面的指针，如果是最左边节点则为FIL_NULL
fil_page_next|（4字节），顾名思义，表示后一个页面的指针，如果是最右边节点则为FIL_NULL
fil_page_LSN|（8字节）该页最后修改对应日志的LSN，与日志、页面刷盘、检查点等有密切关系
fil_page_type|（2字节），偏移为24，页类型
fil_page_file_flush_LSN|（8字节），在数据文件的某一个页才有，代表文件至少被更新到该LSN
fil_page_arch_log_no_or_space_id|（4字节）mysql4.1开始代表数据页属于哪个表空间

###### 页面头信息
page header 用来保存页的信息，共56字节

文件名称| 大小| 说 明
---|---|---
PAGE_N_DIR_SLOTS |2 |page directory 中槽的数量
PAGE_HEAP_TOP |2 |堆中空闲空间的位置( 偏移量)
PAGE_N_HEAP |2| 堆中的记录数量
PAGE_FREE |2| 指向页中空闲空间的位置(偏移量)
PAGE_GARBAGE |2 |已删除记录的字节数,即行记录结构中,delete flag 为1的记录大小的总数
PAGE_LAST_INSERT |2 |最后插入记录的位置( 偏移量)
PAGE_DIRECTION|2|插入的方向
PAGE_N_DIRECTION|2|一个方向连续插入的数量
PAGE_N_RECS|2|该页中记录的数量
PAGE_MAX_TRX_ID|8|当前页的最大事务ID
PAGE_LEVEL|2|当前页在索引中的位置，0x00代表叶子节点
PAGE_INDEX_ID|8|当前页属于哪个索引ID
PAGE_BTR_SEG_LEAF|10|B+树叶节点中文件段的首指针位置，仅B+树的root页中定义
PAGE_BTR_SEG_TOP|10|B+树非叶节点中文件段的首指针位置，仅B+树的root页中定义

######  最大记录和最小记录
- Innodb中，每一个B+树索引都有两个特殊记录，即最大记录和最小记录，限定页面的数据记录边界
- 最大记录和最小记录占用13字节，但实际只需要8字节即可，5字节浪费

###### 页数据空间管理
- 没有任何数据的B+树页面，头部已经存储的数据长度是38+56+13+13=120字节，尾部8字节存储页尾信息。因此PAGE_HEAP_TOP指向偏移120字节的位置
- 只要页面中有空间，就会从堆heap中申请
- 如果记录记录被删除且purge，则空间会进入到PAGE_FREE链表中

###### 槽管理
- Innodb多条记录对应一个槽（达梦一个记录一个槽），槽用来在页面内数据搜索
- 槽本身是排序的，放在页面的最后的位置，槽的长度与页面内存储的记录数又 关系
- 一个槽占2字节，高字节到低字节的顺序存储，最高位槽代表页面索引顺序最小的记录，最低槽代表的是索引顺序最大的记录。增删改的过程中，修改槽的顺序，保证有序
- 搜索采用二分法

###### 页面尾部
- 页头部，偏移为FIL_PAGE_SPACE_OR_CHECKSUM的位置存储了CHECKSUM的值；页尾部的前4个字节，也存储了checksum；读取页面时，会计算checksum，三者比较，相同则说明页面正确
- 页尾部的后4个字节，存储了LSN，与文件头的FIL_PAGE_LSN相同

## 页面重组
- 写入删除频繁，可能会造成很多页面碎片，导致FREE链表有空间却放不下一条记录
```
> show table status like "%test%"\G
```
可使用下面操作回收空间
```
> alter table test0906 engine=innodb;
Query OK, 0 rows affected (0.29 sec)
Records: 0  Duplicates: 0  Warnings: 0
```

## 索引页面的回收
- 填充因子，控制页面数据的删除比例。如果小于，则节点合并
- 分情况讨论
1. 如果Innodb删除之前会检查当前页面剩余记录数。如果只有一条记录，则直接摘除该页面并回收（除根页面，根页面可以为空）
2. 如果删除记录所在页面为内节点，并且记录是页面最左边记录，则删除记录的同时需更新父节点记录
3. 做完上面两步，可以放心删除
- 第一步详述
1. 判断当前页面的兄弟节点，如果没有，则直接删除本节点（实际是B+树本来就为空，会释放整个B+树剩空根节点）
2. 找到父节点，并找到指向被删除节点的指针索引记录，然后用上面所述的删除记录步骤，将这条记录删除
3. 删除上层索引记录后，将本节点从兄弟双向链表中摘除
4. 将被删除的页面归还到本表空间的簇管理链表中

- 相比传统的B+树删除算法，页面不合并相对简单，但容易造成空间浪费和碎片，有些页面长期处于填充因子以下
- 可以日常巡检，回收表空间