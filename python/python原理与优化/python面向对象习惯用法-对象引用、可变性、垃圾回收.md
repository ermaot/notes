
## 变量不是盒子
变量不是存储数值的盒子

```
In [1]: a = [1,2,3,4]

In [2]: b = a

In [3]: a.pop()
Out[3]: 4

In [4]: b
Out[4]: [1, 2, 3]

In [5]: a.remove(1)

In [6]: b
Out[6]: [2, 3]

```

## 标识、相等性和别名
#### 在== 和is 之间选择

```
In [1]: a = [1,2,3,4]

In [2]: b = [1,2,3,4]

In [3]: id(a)
Out[3]: 650080511304

In [4]: id(b)
Out[4]: 650080342728

In [5]: a == b
Out[5]: True

In [6]: a is b
Out[6]: False

```
判断对象是否相等，可以如下：

```
def __eq__(self, other):
        if self.name != other.name:
            return False
        if self.gender != other.gender:
            return False
        if self.age != other.age:
            return False
        return True
```
- == 运算符比较两个对象的值（对象中保存的数据），而 is 比较对象的标识
- is 运算符比 == 速度快，因为它不能重载
-  Python 的is直接比较两个整数 ID。而 a == b 是语法糖，等同于
a.__eq__(b)
#### 元组的相对不可变性
==参见之前的元组内容==

## 默认做浅复制

```
In [1]: l1 = [3, [55, 44], (7, 8, 9)]

//此处可以让l2复制一份l1
In [2]: l2 = list(l1)

In [3]: l1
Out[3]: [3, [55, 44], (7, 8, 9)]

In [4]: l2
Out[4]: [3, [55, 44], (7, 8, 9)]

In [5]: l2 == l1
Out[5]: True

In [6]: l2 is l1
Out[6]: False

//可以看到l2复制的可变部分，仅仅是复制了一个的地址，他们指向的内容是一致的，这会导致改变其中的一个，另外一个会跟着改变
In [7]: id(l1[1])
Out[7]: 1044478399752

In [8]: id(l2[1])
Out[8]: 1044478399752

In [9]: l1[1].append(1)

In [10]: l1
Out[10]: [3, [55, 44, 1], (7, 8, 9)]

In [11]: l2
Out[11]: [3, [55, 44, 1], (7, 8, 9)]

//这里会让可变元素指向新的地址，这样就和之前的地址解耦了。改变一个不会导致另外一个的改变
In [12]: l1[1] = [55,33]

In [13]: id(l1[1])
Out[13]: 1044476666760

In [14]: id(l1[2])
Out[14]: 1044473652640

In [15]: l2
Out[15]: [3, [55, 44, 1], (7, 8, 9)]
```
+= 运算符创建一个新元组，然后重新绑定给原变量，即就地更新
#### 为任意的对象做深复制和浅复制
浅复制 和 深复制

```
In [1]: import copy

In [2]: l1 = [3, [55, 44], (7, 8, 9)]

In [3]: l2 = copy.copy(l1)

In [4]: l3 = copy.deepcopy(l1)

In [5]: l1
Out[5]: [3, [55, 44], (7, 8, 9)]

In [6]: l2
Out[6]: [3, [55, 44], (7, 8, 9)]

In [7]: l3
Out[7]: [3, [55, 44], (7, 8, 9)]

//可以看到，copy只浅层copy了地址；而deepcopy把整个内容全部拷贝了
In [8]: id(l1[1])
Out[8]: 722711798856


In [10]: id(l2[1])
Out[10]: 722711798856

In [11]: id(l3[1])
Out[11]: 722720134664
```
我们可以实现特殊方法 __copy__() 和__deepcopy__()，控制 copy 和 deepcopy 的行为

## 函数的参数作为引用时
函数可能会修改接收到的任何可变对象。对于可变对象和不可变对象，参数传递时选择的方式是不一样的

```
In [2]: def add(a,b):
   ...:     a += b
   ...:     return a
   ...:

In [3]: x,y = 1,2

In [4]: add(1,2)
Out[4]: 3

In [5]: x,y
Out[5]: (1, 2)

In [6]: a,b = [1,2],[3,4]

In [7]: add(a,b)
Out[7]: [1, 2, 3, 4]

In [8]: a,b
Out[8]: ([1, 2, 3, 4], [3, 4])

In [9]: t,u = (1,2),(3,4)

In [10]: add(t,u)
Out[10]: (1, 2, 3, 4)

In [11]: t,u
Out[11]: ((1, 2), (3, 4))
```

#### 不要使用可变类型作为参数的默认值
#### 防御可变参数

```
def __init__(self, passengers=None):
    if passengers is None:
        self.passengers = []
    else:
        self.passengers = list(passengers)
```
其实这样也是有问题的。list函数也是浅复制，如果passenger有可变元素，则还是存在改变的风险
## del 和垃圾回收
- del 语句删除名称，而不是对象。del命令可能会导致对象被当作垃圾回收，但是仅当删除的变量保存的是对象的最后一个引用，或者无法得到对象时。重新绑定也可能会导致对象的引用数量归零，导致对象被销毁
-  CPython 中，垃圾回收使用的主要算法是引用计数（所以很难排除循环引用的问题）
## 弱引用
弱引用不会增加对象的引用数量。引用的目标对象称为所指对象（referent）。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收
#### weak ValueDictionary简介
#### 弱引用的局限
## python对不可变类型实施的把戏