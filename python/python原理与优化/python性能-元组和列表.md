## 本章回答的问题
1. 列表和元组各自适用于什么情况？
2. 查询列表/元组的复杂度是什么？ 
3. 该复杂度是如何计算出来的？ 
4. 列表和元组的区别是什么？ 
5. 向列表添加新项目是如何实现的？ 
6. 我应该在什么情况下使用列表和元组

==写高性能程序最重要的事情是了解你的数据结构所能够提供的性能保证。事实上，高性能编程的很大一部分是了解你查询数据的方式，并选择一个能够迅速响应这个查询的数据结构==

## 列表和元组
- 列表和元组之类的数据结构被称为数组。一个数组是数据在某种内在次序下的扁平列表：列表是动态的数组，而元组则是静态的数组
![一个长度为6的数组的系统内存布局示例](379899E7A4A54D9E96E43103D1D3B916)
- 当创建一个数组（也就是一个列表或元组）时，首先必须分配一块系统内存（其每一段都将被当成是一个整型大小的指向实际数据的指针）。这需要进入内核，操作系统的子进程，去申请使用 N个连续的桶。
- 在列表中查询任意指定元素，只需要知道想要的是哪个元素以及放数据的起始桶是哪个即可。因为所有的数据都占据同样大小的空间（一个“桶”，或者更确切地说，一个整型大小的指向实际数据的指针），我们不需要知道任何关于被存储数据的类型的信息就能够进行计算，复杂度是O(1)

```
In [5]: %%timeit l=range(10)     
         l[5]
   ...: 
10000000 loops, best of 3: 24.8 ns per loop

In [6]: %%timeit l=range(1000000)
         l[100000]
   ...: 
The slowest run took 238.29 times longer than the fastest. This could mean that an intermediate result is being cached 
10000000 loops, best of 3: 25 ns per loop
```
两个结果集相差极大的操作，所用时间基本一样


## 高效搜索
#### 对已排序列表的高效搜索——二分搜索 

```
def binary_search(needle, haystack): 
    imin, imax = 0, len(haystack) 
    while True: 
        if imin >= imax: 
            return -1 
        midpoint = (imin + imax) // 2 
        if haystack[midpoint] > needle: 
            imax = midpoint 
        elif haystack[midpoint] < needle: 
            imin = midpoint+1 
        else: 
            return midpoin
```
和字典查找相比：
1. 比将列表转换成字典然后进行查询要更高效，因为字典查找复杂度是 0(1)，字典转换复杂度却是 O(n)
2. 字典没有重复值，但这个可以有

#### bisect模块
- bisect 提供了一个简便的函数可以在保持排序的同时往列表中添加元素，以及一个高度优化过的二分搜索算法函数来查找元素
- 提供函数可以将新元素直接插入正确的排序位
- 在列表始终排序的情况下，可以轻松找到需要的元素或者跟我们的目标值最接近的元素

```
n [1]: a = [3, 4, 6, 7, 9, 10]

In [2]: import bisect

In [3]: bisect.bisect(a,4)
Out[3]: 2

In [4]: bisect.insort_left(a,5)

In [5]: a
Out[5]: [3, 4, 5, 6, 7, 9, 10]


```

## 列表和元组
1. 列表是动态数组，它们可变且可以重设长度（改变其内部元素的个数） 
2. 元组是静态数组，它们不可变，且其内部数据一旦创建便无法改变。 
3. 元组缓存于Python运行时环境，这意味着我们每次使用元组时无须访问内核去分配内存
4. 列表和元组都可以接受混合类型，这会带来一些额外的开销
#### 列表
动态数组支持 resize操作,列表需要添加数据时，Python 会创建一个新的列表并销毁旧列表，新列表大小的公式如下：

```
//说实话看不懂这个公式
M = (N >> 3) + (N < 9 ? 3 : 6) 
```
#### 元组
- 元组固定且不可变，但可以相加，相加是重新分配空间容纳两个元组的和，因此复杂度是O(n)
- 元组的静态特性可以方便资源缓存