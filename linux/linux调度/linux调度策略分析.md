### linux内核的三种主要调度策略：

---

1. SCHED_OTHER 分时调度策略 
1. SCHED_FIFO实时调度策略，先到先服务 
1. SCHED_RR实时调度策略，时间片轮转

### 实时与分时

---

> 1. 实时进程将得到优先调用，实时进程根据实时优先级决定调度权值
> 1. 分时进程则通过nice和counter值决定权值，nice越小，counter越大，被调度的概率越大，也就是曾经使用了cpu最少的进程将会得到优先调度


### RR和FIFO比较

---

RR和FIFO相同 | 不同
---|---
RR时间片到，重新分配时间片，置于队列尾部| 都是实时任务，就绪的任务可以抢占非实时任务
SCHED_FIFO一直运行，直到自己放弃或者IO或者更高优先级 | 优先级大于0（1~99）
相同优先级，FIFO一个进程不会主动放弃，RR每个任务都会执行一段时间 | 按照可抢占优先级算法


### 所有任务都采用linux分时调度策略时：

---

1. 创建任务指定采用分时调度策略，并指定优先级nice值(-20~19)。
1. 将根据每个任务的nice值确定在cpu上的执行时间(counter)。
1. 如果没有等待资源，则将该任务加入到就绪队列中。
1. 调度程序遍历就绪队列中的任务，通过对每个任务动态优先级的计算权值(counter+20-nice)结果，选择计算结果最大的一个去运行，当这个时间片用完后(counter减至0)或者主动放弃cpu时，该任务将被放在就绪队列末尾(时间片用完)或等待队列(因等待资源而放弃cpu)中。
1. 此时调度程序重复上面计算过程，转到第4步。
1. 当调度程序发现所有就绪任务计算所得的权值都为不大于0时，重复第2步。
 

### 所有任务都采用FIFO时：

---

1. 创建进程时指定采用FIFO，并设置实时优先级rt_priority(1-99)。
1. 如果没有等待资源，则将该任务加入到就绪队列中。
1. 调度程序遍历就绪队列，根据实时优先级计算调度权值(1000+rt_priority),选择权值最高的任务使用cpu，该FIFO任务将一直占有cpu直到有优先级更高的任务就绪(即使优先级相同也不行)或者主动放弃(等待资源)。
1. 调度程序发现有优先级更高的任务到达(高优先级任务可能被中断或定时器任务唤醒，再或被当前运行的任务唤醒，等等)，则调度程序立即在当前任务堆栈中保存当前cpu寄存器的所有数据，重新从高优先级任务的堆栈中加载寄存器数据到cpu，此时高优先级的任务开始运行。重复第3步。
1. 如果当前任务因等待资源而主动放弃cpu使用权，则该任务将从就绪队列中删除，加入等待队列，此时重复第3步。


 
### 所有任务都采用RR调度策略时：

---

1. 创建任务时指定调度参数为RR，并设置任务的实时优先级和nice值(nice值将会转换为该任务的时间片的长度)。
1. 如果没有等待资源，则将该任务加入到就绪队列中。
1. 调度程序遍历就绪队列，根据实时优先级计算调度权值(1000+rt_priority),选择权值最高的任务使用cpu。
1. 如果就绪队列中的RR任务时间片为0，则会根据nice值设置该任务的时间片，同时将该任务放入就绪队列的末尾。重复步骤3。
1. 当前任务由于等待资源而主动退出cpu，则其加入等待队列中。重复步骤3。


### 系统中既有分时调度，又有时间片轮转调度和先进先出调度： 

---

1. RR调度和FIFO调度的进程属于实时进程，以分时调度的进程是非实时进程。
1. 当实时进程准备就绪后，如果当前cpu正在运行非实时进程，则实时进程立即抢占非实时进程。
1. RR进程和FIFO进程都采用实时优先级做为调度的权值标准，RR是FIFO的一个延伸。FIFO时，如果两个进程的优先级一样，则这两个优先级一样的进程具体执行哪一个是由其在队列中的未知决定的，这样导致一些不公正性(优先级是一样的，为什么要让你一直运行?),如果将两个优先级一样的任务的调度策略都设为RR,则保证了这两个任务可以循环执行，保证了公平。


