## 内存映射
- 我们通常说的内容容量，指的是物理内存，即动态随机访问内存（DRAM）。==只有内核才能直接访问物理内存==
- linux内核给每个进程都提供了独立的==虚拟地址空间==，并且地址空间是连续的，可以方便进程访问
- 虚拟地址空间分为内核空间和用户控件，不同字长的处理器（32bit和64bit），地址空间的范围也不同
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A31.png)
- 进程在用户态时，只能访问用户内存空间；内核态，可以访问内核空间内存
- 并不是所有的虚拟内存都会被分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后使用内存映射管理
- 内存映射，就是将虚拟内存地址映射到物理内存地址。为了完成内存映射，内核为每个进程维护一张页表，记录虚拟地址和物理地址的映射关系
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A32.png)
- 页表存储在CPU的内存管理单元MMU中，处理器（正常情况下）直接通过硬件找出要访问的内存
- 进程访问的虚拟地址在页表中查询不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、更新进程页表、最后再返回用户空间恢复进程运行
- TLB（translation lookaside buffer转译后备缓冲）是MMU中页表的高速缓存，比MMU快，所以减少进程上下文切换，就能减少TLB刷新次数，提高TLB缓存利用率，提高CPU内存访问的性能
- MMU用页管理内存（4KB），页表可能会比较大，，linux提供了多级页表和大页（huge page）
- 多级页表把内存分成区块管理，将原来的映射关系改成区块索引和区块内的偏移
- linux用四级页表。虚拟地址被分为5个部分，前四个表用于选择，最后一个索引表示页内偏移
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A33.png)
- 大页是比普通页大的内存块，常见大小有2MB和1GB。使用在大量内存的进程上，比如oracle和DPDK等

## 虚拟内存空间的分布
#### 虚拟内存空间的具体分布
![32bit系统的虚拟内存空间](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A34.png)
用户空间内存，从低到高是五种不同的内存段
1. 只读段，包括代码和常量
2. 数据段，包括全局变量等
3. 堆，包括动态分配的内存，从低地址向上增长
4. 文件映射段，包括动态库，共享内存等，从高地址开始向下增长
5. 栈，包括局部变量和函数调用的上下文等。栈大小一般是8MB，固定
- 这5个内存段中，堆和文件映射段的内存是动态分配的。malloc在堆上动态分配，mmap在文件映射段动态分配

## 内存的分配与回收
- malloc是C标准库提供的内存分配函数，对应系统调用有两种实现方式，brk()和mmap()
- 对于小内存（128k以下），使用brk，通过移动堆顶的位置分配，释放后不立即归还系统，被缓存起来可以重复利用。brk可以减少缺页异常的发生，提高内存访问效率，但在内存工作繁忙时容易造成内存碎片
- 对于大块内存（大于128k），直接使用内存映射mmap，即在文件映射段找一块空闲内存分配出去。释放时直接归还系统，每次mmap都会发生缺页异常，频繁缺页会造成内核管理负担，因此只在大块内存分配时用mmap
- 调用内存分配时，并没真正分配，首次访问时才分配，即通过缺页异常进入内核，由内核分配
- linux用==伙伴系统==管理内存。伙伴系统也以页管理内存，并通过相邻页合并，减少内存碎片
- 比页小的对象，linux通过slab分配器管理。slab可以看做伙伴系统的缓存，主要用来分配并释放内核中的小对象
- 当内存紧张时，系统会通过以下方式回收内存
1. 回收缓存，比如LRU算法，回收最近使用最少的内存页面
2. 回收不常访问的内存，通过交换分区直接写入磁盘中。暂时不用的数据存储到磁盘（换出）；进程访问这些内存时，再从磁盘读取这些数据（换入）。swap在内存不够的时候才使用，并可能造成严重的性能问题
3. 杀死进程，通过OOM（out of Memory）直接杀死进程释放内存。OOM是内核保护机制，监控进程的内存使用情况，并使用OOM_score为进程的内存使用情况评分
- OOM_Score
1. 进程消耗的内存越大，OOM_SCORE越大
2. 进程使用的CPU越多，OOM_SCORE越小
OOM_SCORE越大越容易被系统杀死。可以通过命令调整
```
# cat /proc/$(pidof sshd)/oom_adj

# cat /proc/8429/oom_score
49
# cat /proc/8429/oom_adj 
0

echo -16 > /proc/$(pidof sshd)/oom_adj

```
3. OOM_adj范围是[-17,15]。数值越大越容易被OOM。-17表示禁止OOM

## 查看内存使用情况
#### free

```
# free（查看整体内存情况）
              total        used        free      shared  buff/cache   available
Mem:        8009704     3327068     1954972         668     2727664     4358224
Swap:             0           0           0
```
列名|说明
---|---
total|总内存大小
used|已用内存大小，包含共享内存
free|未使用内存大小
shared|共享内存大小
buff/cache|缓存和缓冲区大小
available|新进程可用内存大小。包括未使用内存和可回收的缓存

#### top（按m进入内存显示）

```
# top
top - 19:11:13 up 197 days, 16:55,  3 users,  load average: 0.04, 0.04, 0.05
Tasks:  84 total,   1 running,  83 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.8 us,  0.5 sy,  0.0 ni, 98.7 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8009704 total,  1951180 free,  3330252 used,  2728272 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  4354804 avail Mem 

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND                                                                           
10551 root      10 -10  127572  11992   9292 S   1.7  0.1 129:31.28 AliYunDun                                                                         
 8429 mysql     20   0 1851132 397120  15700 S   0.7  5.0 142:18.05 mysqld                                                                            
29804 java      20   0 4820452   1.1g  12504 S   0.7 14.0 403:47.93 java                                                                              
24133 root      20   0  161840   2204   1596 R   0.3  0.0   0:00.09 top                                                                               
    1 root      20   0   43400   3612   2400 S   0.0  0.0   2:20.96 systemd                                                                           
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.32 kthreadd                                                                          
    3 root      20   0       0      0      0 S   0.0  0.0   0:05.08 ksoftirqd/0                                                                       
    5 root       0 -20       0      0      0 S   0.0  0.0   0:00.00 kworker/0:0H                                                                      
    7 root      rt   0       0      0      0 S   0.0  0.0   0:01.23 migration/0   
```
列名|说明
---|---
VIRT|进程的虚拟内存大小，只要是进程申请过的内存，即使还没真正物理分配，也计算
RES|常驻内存大小，即进程世纪使用的物理内存，但不包括swap和共享内存
SHR|共享内存大小，比如与其他进程共同使用的共享内存、加载的动态链接库和程序代码段
%MEM|进程使用物理内存占系统总内存的比例
- 虚拟内存通常并不会全部分配物理内存，所以VIRT比RES大得多
- 共享SHR并不一定是共享的。比如程序代码段、非共享的动态链接库、以及进程间真正的共享内存都算SHR。

## buffer和cache
free命令的手册中，看到
- buffers是内核缓冲区用到的内存，对应是proc/meminfo中的buffers的值
- cache是内核页缓存与slab用到的内存，对应的是/proc/meminfo中的cached和SReclaimable之和

#### proc文件系统
- /proc是linux内核提供的一种特殊文件系统，是用户与内核交互的接口；可以从/proc查询内核运行状态和配置选项，查询进程的运行状态、统计数据等，可以通过proc修改内核配置
- buffers是对原始磁盘块的临时存储和用来缓存磁盘的数据（通常不大，20MB左右）。内核可以合并多次的小的写为一次大的写操作
- cached是磁盘读取文件的页缓存，即缓存从文件读取的数据
- SReclaimable是slab的一部分。slab宝库欧SReclaimable（可回收），SUnreclaim（不可回收）

原文[内存耗用：VSS/RSS/PSS/USS 的介绍](https://www.jianshu.com/p/3bab26d25d2e)
#### VSS、RSS、PSS、USS
1. VSS - Virtual Set Size （用处不大）
虚拟耗用内存（包含共享库占用的全部内存，以及分配但未使用内存）。其大小还包括了可能不在RAM中的内存（比如虽然malloc分配了空间，但尚未写入）。VSS 很少被用于判断一个进程的真实内存使用量。
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A35.png)
2. RSS - Resident Set Size （用处不大）
实际使用物理内存（包含共享库占用的全部内存）。但是RSS还是可能会造成误导，因为它仅仅表示该进程所使用的所有共享库的大小，它不管有多少个进程使用该共享库，该共享库仅被加载到内存一次。所以RSS并不能准确反映单进程的内存占用情况
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A36.png)
3. PSS - Proportional Set Size （仅供参考）
实际使用的物理内存（比例分配共享库占用的内存，按照进程数等比例划分）。例如：如果有三个进程都使用了一个共享库，共占用了30页内存。那么PSS将认为每个进程分别占用该共享库10页的大小。PSS是非常有用的数据，因为系统中所有进程的PSS都相加的话，就刚好反映了系统中的   总共占用的内存。而当一个进程被销毁之后，其占用的共享库那部分比例的PSS，将会再次按比例分配给余下使用该库的进程。这样PSS可能会造成一点的误导，因为当一个进程被销毁后，PSS不能准确地表示返回给全局系统的内存
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A37.png)
4. USS - Unique Set Size （非常有用）
进程独自占用的物理内存（不包含共享库占用的内存）。USS是非常非常有用的数据，因为它反映了运行一个特定进程真实的边际成本（增量成本）。当一个进程被销毁后，USS是真实返回给系统的内存。当进程中存在一个可疑的内存泄露时，USS是最佳观察数据。
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A38.png)

## 缓存命中率
缓存命中率，是指直接通过缓存获取数据的请求次数与总请求次数的比值。命中率越高，表示使用缓存带来的收益越高，应用程序的性能越好
#### cachestat 和 cachetop
- cachestat 提供了整个操作系统缓存的读写命中情况。
- cachetop 提供了每个进程的缓存命中情况。
- 两个工具来自于bcc软件包的一部分，linux4.1以上支持，centos需要升级内核

```
cachestat 1 3
   TOTAL   MISSES     HITS  DIRTIES   BUFFERS_MB  CACHED_MB
       2        0        2        1           17        279
       2        0        2        1           17        279
       2        0        2        1           17        279 

```
指标|说明
---|---
TOTAL |表示总的 I/O 次数
MISSES |表示缓存未命中的次数；
HITS |表示缓存命中的次数；
DIRTIES| 表示新增到缓存中的脏页数；
BUFFERS_MB |表示 Buffers 的大小，以 MB 为单位；
CACHED_MB |表示 Cache 的大小，以 MB 为单位。


```
cachetop
11:58:50 Buffers MB: 258 / Cached MB: 347 / Sort: HITS / Order: ascending
PID      UID      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
   13029 root     python                  1        0        0     100.0%       0.0%

```
它的输出跟 top 类似，默认按照缓存的命中次数（HITS）排序，展示了每个进程的缓存命中情况。具体到每一个指标，这里的 HITS、MISSES 和 DIRTIES ，跟 cachestat 里的含义一样，分别代表间隔时间内的缓存命中次数、未命中次数以及新增到缓存中的脏页数。而 READ_HIT 和 WRITE_HIT ，分别表示读和写的缓存命中率。

## pcstat
```
# pcstat /bin/lscpu 
|------------+----------------+------------+-----------+---------|
| Name       | Size           | Pages      | Cached    | Percent |
|------------+----------------+------------+-----------+---------|
| /bin/lscpu | 100696         | 25         | 25        | 100.000 |
|------------+----------------+------------+-----------+---------|
# pcstat /bin/sb 
|----------+----------------+------------+-----------+---------|
| Name     | Size           | Pages      | Cached    | Percent |
|----------+----------------+------------+-----------+---------|
| /bin/sb  | 80872          | 20         | 0         | 000.000 |
|----------+----------------+------------+-----------+---------|
```

```
# echo 3 >/proc/sys/vm/drop_caches 
```

#### pcstat案例
1. 生成一个临时文件
```
# dd if=/dev/sda1 of=file bs=1M count=512
```

2. 清理缓存
```
echo 3 > /proc/sys/vm/drop_caches
```
3. 查看pcstat
```
# pcstat file
|----------+----------------+------------+-----------+---------|
| Name     | Size           | Pages      | Cached    | Percent |
|----------+----------------+------------+-----------+---------|
| file     | 536870912      | 131072     | 0         | 000.000 |
|----------+----------------+------------+-----------+---------|
```
4. dd命令测试文件的读取速度
由于在 dd 命令运行前我们已经清理了缓存，所以 dd 命令读取数据时，肯定要通过文件系统从磁盘中读取。
```
# dd if=file of=/dev/null bs=1M
512+0 records in
512+0 records out
536870912 bytes (537 MB) copied, 4.93452 s, 109 MB/s
```
5. 再度dd
```
# dd if=file of=/dev/null bs=1M
512+0 records in
512+0 records out
536870912 bytes (537 MB) copied, 0.139499 s, 3.8 GB/s

# pcstat file
|----------+----------------+------------+-----------+---------|
| Name     | Size           | Pages      | Cached    | Percent |
|----------+----------------+------------+-----------+---------|
| file     | 536870912      | 131072     | 131072    | 100.000 |
|----------+----------------+------------+-----------+---------|
```
这两次结果说明，系统缓存对第二次 dd 操作有明显的加速效果，可以大大提高文件读取的性能。


## 内存泄漏
内存泄漏的原因：
- 没正确回收分配后的内存，导致了泄漏。
- 访问的是已分配内存边界外的地址，导致程序异常退出，等等。
- 用户空间内存包括多个不同的内存段，比如只读段、数据段、堆、栈以及文件映射段
1. 栈内存由系统自动分配和管理。一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。
2. 堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 
3. 只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。
4. 数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏。
5. 最后一个内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。

##### memleak
```
# -a 表示显示每个内存分配请求的大小以及地址
# -p 指定案例应用的 PID 号
$ /usr/share/bcc/tools/memleak -a -p $(pidof app)
WARNING: Couldn't find .text section in /app
WARNING: BCC can't handle sym look ups for /app
    addr = 7f8f704732b0 size = 8192
    addr = 7f8f704772d0 size = 8192
    addr = 7f8f704712a0 size = 8192
    addr = 7f8f704752c0 size = 8192
    32768 bytes in 4 allocations from stack
        [unknown] [app]
        [unknown] [app]
        start_thread+0xdb [libpthread-2.27.so] 

```

## swap
- 文件页（file-backed page）：进程的代码、文件的映射，和文件有关，属于文件页，大部分可以直接回收，因为可以从磁盘读取。两种方式写入磁盘：
1. 可以在应用程序中，通过系统调用fsync，同步脏页
2. 可以交给系统，由内核线程pdflush负责脏页刷新
- 匿名页（Anonymous page）应用程序动态分配的堆内存：可能被再次访问，不能直接回收
#### swap原理
- 包括换入换出的过程
1. 换出，把进程暂时不用的内存数据存储到磁盘中，并释放占用的内存
2. 换入，在进程再次访问这些内存的时候，把它们从磁盘读到内存中
- 笔记本休眠和快速开机功能，基于swap
- 何时算内存紧张？
1. 大块内存请求，但内存不足。此时需要回收一部分内存，通常称为直接内存回收
2. 还有专门的内核线程定期回收内存，即kswapd0。衡量内存使用情况
- kswapd0定义了三个内存阈值：页最小阈值（pages_min），页低阈值（pages_low），页高阈值（pages_high）。剩余内存用pages_free表示
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A39.png)
1. 剩余内存小于页最小阈值，说明进程可用内存都耗尽了，只有内核才可以分配内存。
2. 剩余内存落在页最小阈值和页低阈值中间，说明内存压力比较大，剩余内存不多了。这时 kswapd0 会执行内存回收，直到剩余内存大于高阈值为止。
3. 剩余内存落在页低阈值和页高阈值中间，说明内存有一定压力，但还可以满足新内存请求。
4. 剩余内存大于页高阈值，说明剩余内存比较多，没有内存压力。
5. 页的阈值可以通过页最低阈值/proc/sys/vm/min_free_kbytes设置：

```
pages_low = pages_min*5/4
pages_high = pages_min*3/2
```
#### NUMA和swap
numa架构下，多个处理器被划分到不同的Node上，每个Node都有自己的本地内存空间，同一个Node内部的内存空间可分为内存域（zone），比如内存访问区（DMA）、普通内存区（Normal）、伪内存区（movable）
![image](https://github.com/ermaot/notes/blob/master/linux/%E6%80%A7%E8%83%BD/pic/%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A310.png)
- numactl查看node的情况
```
# numactl --hardware
available: 1 nodes (0)
node 0 cpus: 0 1
node 0 size: 8191 MB
node 0 free: 211 MB
node distances:
node   0 
  0:  10 
```
- 查看页最小阈值、页最低阈值、页最高阈值

```
# cat  /proc/zoneinfo 
Node 0, zone      DMA
  pages free     3975
        min      33
        low      41
        high     49
        scanned  0
        spanned  4095
        present  3998
        managed  3977
    nr_free_pages 3975
    nr_alloc_batch 8
    nr_inactive_anon 0
    nr_active_anon 0
    nr_inactive_file 0
    nr_active_file 0
    nr_unevictable 0
```
1. pages处的min、low、high就是内存阈值，free是剩余内存页数，与nr_free_pages相同
2. nr_zone_active_anon和nr_zone_inactive_anon分别是活跃和非活跃的匿名页数
3. nr_zone_active_file和nr_zone_inactive_file分别是活跃和非活跃的文件页数
- 某个node内存不足，系统可以从其他node寻找空闲内存，也可以从本地内存中回收内存，用zone_reclaim_mode调整方式
```
# cat /proc/sys/vm/zone_reclaim_mode 
0
```
默认0，是可以从其他node寻找内存；1，2，4表示值回收本地内存，2表示会写脏数据回收内存，4表示可以用swap方式回收内存

#### swappiness
- 回收既包括文件页（直接回收，或者脏页写回磁盘后回收），也包括匿名页（通过swap机制，写入磁盘再释放内存）
- linux使用/proc/sys/vm/swappiness 调整使用swap的积极程度。该值范围0~100，越大越积极倾向于使用swap和回收匿名页。当为0，也可能会swap

#### swap分区与swap文件

```
# 创建 Swap 文件
$ fallocate -l 8G /mnt/swapfile
# 修改权限只有根用户可以访问
$ chmod 600 /mnt/swapfile
# 配置 Swap 文件
$ mkswap /mnt/swapfile
# 开启 Swap
$ swapon /mnt/swapfile

```
#### 查看某个进程的swap

```
# cat /proc/723/status | grep ^VmSwap
VmSwap:	       0 kB
```
#### 清理swap

```
# swapoff -a && swapon -a 

```


## 如何定位内存问题
#### 内存指标
- 系统内存部分
1. 已用内存和剩余内存就是已经使用和还未使用的内存。
2. 共享内存是通过 tmpfs 实现的，所以它的大小也就是 tmpfs 使用的内存大小。tmpfs 其实也是一种特殊的缓存。
3. 可用内存是新进程可以使用的最大内存，它包括剩余内存和可回收缓存。
4. 缓存包括两部分，一部分是磁盘读取文件的页缓存，用来缓存从磁盘读取的数据，可以加快以后再次访问的速度。另一部分，则是 Slab 分配器中的可回收内存。
5. 缓冲区是对原始磁盘块的临时存储，用来缓存将要写入磁盘的数据。这样，内核就可以把分散的写集中起来，统一优化磁盘写入。
- 进程内存部分
1. 虚拟内存，包括了进程代码段、数据段、共享内存、已经申请的堆内存和已经换出的内存等。这里要注意，已经申请的内存，即使还没有分配物理内存，也算作虚拟内存。
2. 常驻内存是进程实际使用的物理内存，不过，它不包括 Swap 和共享内存。
3. 共享内存，既包括与其他进程共同使用的真实的共享内存，还包括了加载的动态链接库以及程序的代码段等。
4. Swap 内存，是指通过 Swap 换出到磁盘的内存。

#### 缺页异常
系统调用内存分配请求后，并不立刻分配物理内存，而在请求首次访问时，通过缺页异常来分配
- 可以直接从物理内存中分配时，被称为次缺页异常
- 需要磁盘IO接入（比如swap），被称为主缺页异常
#### swap使用情况
swap️已用空间、剩余空间、换入速度和换出速度，换入换出速度表示每秒钟换入和换出内存大小==（如何查看==）
#### 内存性能工具
- free：查看系统整体内存和swap情况
- top、ps，查看内存使用情况
- proc系统查看内存指标
- vmstat动态观察内存变化
- cachestat查看整个系统缓存的读写命中
- cachetop观察每个进程缓存的读写命中
- memleak确认发生内存泄漏与内存分配栈

![image](F351CF033D7C41799B29F1ADD861EEB0)

![image](28B51E7F28114956A2C10346053EBE19)

#### 分析步骤
1. 先用 free 和 top，查看系统整体的内存使用情况。
2. 再用 vmstat和pidstat，查看一段时间的趋势，从而判断出内存问题的类型。
3. 最后进行详细分析，比如内存分配分析、缓存/缓冲区分析、具体进程的内存使用分析等。
![image](5A14FF7978AD49498AC6C740FC36DD90)