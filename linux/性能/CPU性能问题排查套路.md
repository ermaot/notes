## 进程状态解释
```
ps aux
```
- 状态分为R，D，S，I，Z，T，X等几种
1. R：running或runnable，运行状态或者就绪状态
2. D：disk sleep，也就是不可中断状态睡眠（ininterruptible sleep），一般表示正在跟硬件交互，不允许被其他进程打断
3. S：interruptible sleep，可中断睡眠。表示进程因为等待某个事件而被系统挂起，如果该事件发生，就会被唤醒并进入R状态
4. I：idle状态，就是空闲状态。用在不可中断睡眠的内核线程上。对某些内核线程，可能并无负载，区分于D状态的不可中断睡眠进程
5. Z：zombie状态，就是进程已经结束，但父进程尚未回收它的资源
6. T或者t：就是stopped或者traced缩写，表示进程处于暂停或者跟踪状态（向一个进程发送SIGSTOP信号，就会进入stopped；再发送SIGCONT信号，进程又会恢复运行；被gdb等调试器调试的时候，使用断点进入中断后，进程就会变成跟踪状态）
7. X，就是Dead。不会在top或者ps中看到

- 不可中断状态，是为了进程数据和硬件状态一致，一般正常情况下会很快结束。如果不可中断持续很久，说明系统或者硬件发生故障，甚至会导致大量不可中断进程
- 僵尸进程会经常碰到。一般进程创建子进程后，应该通过系统调用wait()或者waitpid()等待子进程结束并回收资源；而子进程在结束后会向父进程发送SIGCHLD信号。父进程可以注册SIGCHLD信号处理函数异步回收资源。如果父进程没有这么做，或者子进程执行太快父进程还没来得及处理，子进程就会变成僵尸进程。一般僵尸进程持续比较短；大量僵尸进程会用尽PID进程号

## iowait升高分析过程
1. dstat命令查看IO和CPU情况，确认iowait与磁盘读写的关系
2. top观察D状态的进程，获得进程ID
3. 通过pidstat查看进程的读写情况
4. 使用strace命令，查看进程的调用过程
5. 如果进程无读写，则使用perf record -g记录性能事件，然后perf record查看调用关系
6. 分析造成问题的函数
- O_DIRECT 选项打开磁盘的直接读写，越过缓存阶段

## 僵尸进程的分析方法
找出父进程，然后在父进程里解决
```
# pstree -aps 19327
systemd,1 --system --deserialize 22
  └─sshd,3046 -D
      └─sshd,19219    
          └─bash,19221
              └─mysql,19327 -u root -p
```


## 几个案例的具体过程

#### 平均负载的案例。
1. 我们先用 uptime， 查看了系统的平均负载
2. 在平均负载升高后，又用 mpstat 和 pidstat  ，分别观察了每个 CPU 和每个进程 CPU 的使用情况，进而找出了导致平均负载升高的进程，也就是我们的压测工具 stress。


#### 上下文切换的案例。
1. 我们先用 vmstat ，查看了系统的上下文切换次数和中断次数
2. 然后通过 pidstat，观察了进程的自愿上下文切换和非自愿上下文切换情况；
3. 最后通过 pidstat，观察了线程的上下文切换情况，找出了上下文切换次数增多的根源，也就是我们的基准测试工具 sysbench。

#### 进程 CPU 使用率升高的案例。
1. 我们先用 top  ，查看了系统和进程的 CPU 使用情况，发现 CPU 使用率升高的进程是 php-fpm；
2. 再用 perf top  ，观察 php-fpm 的调用链，最终找出 CPU 升高的根源，也就是库函数 sqrt() 。

#### 系统的 CPU 使用率升高的案例。
1. 我们先用  top 观察到了系统 CPU 升高，但通过 top 和 pidstat  ，却找不出高 CPU 使用率的进程
2. 于是，我们重新审视 top 的输出，又从 CPU 使用率不高但处于 Running 状态的进程入手，找出了可疑之处
3. 最终通过  perf record 和 perf report ，发现原来是短时进程在捣鬼。
4. 另外，对于短时进程，专门的工具 execsnoop，可以实时监控进程调用的外部命令。
5. 


## 性能优化效果评估方法
#### 步骤
分三步走
- 确定性能的量化指标
1. 对于应用程序，指标可以是吞吐量和请求延迟（我觉得可能还需要并发度）
2. 对于系统资源，可以从CPU利用率
- 测量优化钱的性能指标
- 测量优化后的性能指标

#### 注意事项
1. 避免测试程序对性能的影响
2. 避免外部环境变化影响指标。

#### 多个性能问题同时存在
- 80%的问题由20%的代码导致，所以找出20%就能优化80%的性能。因此==并非所有的性能问题都值得优化==
- 优化之前，先把所有的性能问题分析一遍，找出最重要、能最大程度提升性能的问题。可能解决这一个就能解决全部的问题
- 多问题依然存在，则需要分别测试，步骤如下
1. 如果是系统资源达到瓶颈，首先优化系统资源使用的问题
2. 针对不同类型的指标，首先去优化那些由瓶颈导致、性能指标变化幅度最大的问题

#### 多种优化方法，如何选择
- 考虑性能优化，需要综合多方面的因素，不能“一步登天”，而应该循序渐进，而且要有自己的思考
- ==举例：DPDK分析==（此处暂放）

####CPU优化方法
###### 应用程序优化
1. 排除不必要的工作，只保留最核心的逻辑（减少循环层次，减少递归，减少动态内存分配）等
2. 编译器优化：比如gcc优化选项-O2
3. 算法优化：使用复杂度更低的算法
4. 异步处理。比如将轮询替换为时间通知
5. 多线程代替多进程：避免进程上下文切换
6. 善用缓存：缓存中间结果，加快处理速度

###### 系统优化
一方面充分利用CPU缓存的本地性，加快缓存访问；另一方面控制进程的CPU使用，减少进程间的相互影响
1. CPU绑定：将进程绑定到一个或者多个CPU上，可以提高CPU的缓存命中率，减少跨CPU调度带来的上下文切换
2. CPU独占：跟CPU绑定类似，将CPU分组，并通过CPU亲和性为其分配进程
3. 优先级调整：使用nice调整进程优先级，正直调低负值调高
4. 为进程设置资源限制：使用linux cgroups设置进程的CPU使用上限，可以防止某个应用程序自身的问题耗尽系统资源
5. NUMA优化（None-Uniform Memory Access）优化：支持NUMA的处理器会被划分为多个node，每个node都有自己的本地空间。NUMA优化，就是让CPU尽可能只访问本地内存
6. 中断负载均衡：软中断或者硬中断的处理程序都会耗费大量CPU，开启irqbalance或者smp_affinity，可以把中断处理过程自动负载均衡到多个CPU上

#### 千万别过早优化
==过早优化是万恶之源==